#!/usr/bin/env python
"""
Module containing classes and functions for analysis of deepseq data related to insertional mutant libraries.

This is a module to be imported and used by other programs.  Running it directly runs the built-in unit-test suite.

 -- Weronika Patena, Jonikas Lab, Carnegie Institution, 2011
"""

# basic libraries
import sys, re
import unittest
from collections import defaultdict
# other libraries
import HTSeq
from BCBio import GFF
from Bio import SeqFeature
# my modules
from DNA_basic_utilities import SEQ_ENDS, SEQ_STRANDS, SEQ_DIRECTIONS, SEQ_ORIENTATIONS, position_test_contains, position_test_overlap
from deepseq_utilities import get_seq_count_from_collapsed_header, check_mutation_count_try_all_methods


class SPECIAL_GENE_CODES(object):
    not_determined = "gene_unknown"
    chromosome_not_in_reference = "unknown_chrom"
    not_found = "no_gene_found"
# it seems like I have to set SPECIAL_GENE_CODES.all_codes afterward because I can't access __dict__ from inside the class
SPECIAL_GENE_CODES.all_codes = [value for (name,value) in SPECIAL_GENE_CODES.__dict__.items() if not name.startswith('__')]


### Various functions

# MAYBE-TODO these could probably go in basic_programs/deepseq_utilities or something...

def parse_gene_pos_file(genefile):
    """ Parse a gff file using the GFF class from BCBio; return a chromosome:data dictionary."""
    # LATER-TODO add some options to specify the limits?  Sometimes I will want intron/exon/UTR and not just gene...  And sometimes I may want to do this by chromosome instead of all at once to not use too much memory?
    genefile_parsing_limits = {'gff_type': ['gene']}
    reference_by_chromosome = {}
    with open(genefile) as GENEFILE:
        for record in GFF.parse(GENEFILE, limit_info=genefile_parsing_limits):
            #if options.verbose:   print "\tparsing %s..."%record.id
            reference_by_chromosome[record.id] = record
    # For checking various things in the gff file that are unrelated to mutant-location, see gff_examine_file.py
    return reference_by_chromosome
    # MAYBE-TODO add unit test?  Not sure if worth it, it's only a simple wrapper around BCBio.GFF, and would need a lot of fake data/files to test properly.


def find_gene_by_pos(position_data, reference_by_chromosome, position_test_function, 
                     chromosomes_seen_already=set(), error_for_tests=False):
    """ Look up position_data in reference_by_chromosome; return gene ID and orientation of position vs gene.

    If the location given by position_data is inside a gene in the reference_by_chromosome dictionary, 
     return geneID and orientation ('sense' if position_data and gene are in the same direction, 'antisense' otherwise); 
     if location is not in a gene, return ('no_gene_found', '') or ('unknown_chrom','').

    Reference_by_chromosome is a chrom:record dict generated by parse_gene_pos_file using BCBio.GFF parser. 
    Position_test_function is a function that takes gene_start,gene_end,pos_start,pos_end and returns True if pos in gene.
    Chromosomes_seen_already is a list used to store data between function runs, in order to suppress repeated warnings 
     about chromosome names absent in reference_by_chromosome. A pre-populated list can be passed if desired.
    """
    # see notes_on_GFF_parsing.txt for what a GFF record (reference_by_chromosome[chromosome]) will be like
    assert position_data.strand in ['+','-'], "Strand should be %s, and is %s!"%(' or '.join(SEQ_STRANDS),strand)
    # fail gracefully when you see an unexpected "chromosome"; keep track in order to only print the warning once
    if not position_data.chromosome in reference_by_chromosome.keys():
        if not position_data.chromosome in chromosomes_seen_already:
            # Normally I want printing, but when running tests it's hard to test printing, so adding an exception option
            info = 'Warning: chromosome "%s" not found in genefile data! (No further warnings will be shown)'%(chromosome)
            if error_for_tests:     raise ValueError(info)
            else:                   print(info)
        chromosomes_seen_already.add(position_data.chromosome)
        return SPECIAL_GENE_CODES.chromosome_not_in_reference, '?'
    # if the chromosome is in the record, go over all the genes in it and look for one that matches the position
    #   (using position_test_function, which was passed as an argument - it can be more or less strict)
    for gene in reference_by_chromosome[position_data.chromosome].features:
        if position_test_function(gene.location.start.position, gene.location.end.position, 
                                  position_data.min_position, position_data.max_position):
            if gene.strand==1:      orientation = 'sense' if position_data.strand=='+' else 'antisense'
            elif gene.strand==-1:   orientation = 'sense' if position_data.strand=='-' else 'antisense'
            else:                   orientation = '?'
            return gene.id, orientation
    return SPECIAL_GENE_CODES.not_found, '?'
    # MAYBE-TODO add unit test?


### Functions/classes for dealing with alignment/insertion positions

def make_joint_position(val_or_list):
    """ Takes a number or an iterator of numbers; returns biopython ExactPosition(val) or WithinPosition(min,max-min). """
    # Do I even need this SeqFeature.ExactPosition/SeqFeature.WithinPosition thing from biopython here?  
    #   I might as well use them, I guess, but I could write something of my own too.
    if val_or_list is None:         
        return None
    if (val_or_list is True) or (val_or_list is False): 
        raise ValueError("Argument to make_joint_position can't be True/False!")
    try:
        min_val = int(min(val_or_list))
        max_val = int(max(val_or_list))
        if min_val==max_val:    return SeqFeature.ExactPosition(min_val)
        else:                   return SeqFeature.WithinPosition(min_val, min_val-max_val)
    except TypeError:           return SeqFeature.ExactPosition(int(val_or_list))


class Insertion_position():
    """ A descriptor of the position of a genomic insertion, with handling of before/after sides and ambiguity.

    Attributes: 
     - chromosome and strand - the chromosome the insertion is on, and the strand it's in sense orientation to.
     - position_before and position_after - positions before and after the insertion site (1-based), or None if unknown;
        use biopython SeqFeature objects (ExactPosition for a single base, or WithinPosition when there's ambiguity).
     - min_position and max_position - lowest/highest possible position values as plain numbers, no ambiguity
     - full_position - a string describing the full position: 3-4 for exact positions, 3-? or 4-? if one side is unknown, 
        (2.3)-4 or 3-(4.6) for ambiguous positions that could be anywhere within a range.
     - chromosome_name, chromosome_number - two parts of chromosome string: 'chr1'->('chr','1'), 'abc'->('abc','')
     - all_position_values - all sorting-relevant information: chrome name, number, min_position, max_position, strand

    Methods: 
     - printing: __str__ returns full_position
     - comparison: __cmp__ is based on all_position_values 
    """

    def __init__(self, chromosome, strand, position_before=None, position_after=None):
        """ Initialize all the values - most are straightforward; dealing with positions is a bit complicated. 
        
        The two position_* arguments can be numbers, or iterators of numbers interpreted as a range of positions, 
         from which a min and max value is taken to form a biopython WithinPosition. 
        At least one of the position_* arguments must be provided; if one isn't provided, the value is left as None.
        Min_position and max_position are calculated based on both of the arguments, or whichever one isn't None.
        Chromosome, strand, chromosome_name/number, full_position and all_position values are simple - see class docstring.
        """
        if (position_before is None) and (position_after is None):
            raise ValueError("can't create an Insertion_position object with no known position values!")
        self.chromosome = chromosome
        self.strand = strand
        self.position_before = make_joint_position(position_before)
        self.position_after = make_joint_position(position_after)
        ### non-obvious position descriptors
        if self.position_after is None:
            self.min_position = self.position_before.position
            self.max_position = self.position_before.position+1
        elif self.position_before is None:
            self.min_position = self.position_after.position-1
            self.max_position = self.position_after.position
        else:
            self.min_position = min(self.position_before.position, self.position_after.position-1)
            self.max_position = max(self.position_before.position+1, self.position_after.position)
        self.full_position = str(self)
        # split chromosome into name and number (if it has a number), to make chromosome 16 sort after 5 instead of before
        chromosome_data = re.search('^(.*[^\d]?)(\d*)', self.chromosome)
        self.chromosome_name = chromosome_data.group(1)
        self.chromosome_number = int(chromosome_data.group(2)) if chromosome_data.group(2) else 0
        self.all_position_values = (self.chromosome_name, self.chromosome_number, 
                                    self.min_position, self.max_position, self.strand)

    # LATER-TODO add some kind of merge function to merge two positions into one!  For when I'm merging two position-based read groups together because they're actually probably the same mutant with some sequencing errors.

    def __cmp__(self,other):
        return cmp(self.all_position_values, other.all_position_values)

    def __str__(self): 
        divider = '-'
        info_before = str(self.position_before) if self.position_before is not None else '?'
        info_after = str(self.position_after) if self.position_after is not None else '?'
        return info_before+divider+info_after

    # LATER-TODO add unit tests for this whole class!


def get_insertion_pos_from_HTSeq_read_pos(HTSeq_pos, cassette_end, reads_are_reverse=False):
    """ Return a Insertion_position instance giving the cassette insertion position based on HTSeq read position. 

    HTSeq_pos should be a HTSeq.GenomicPosition instance; cassette_end gives the side of the insertion that read is on; 
     reads_are_reverse is True if the read is in reverse orientation to the cassette, False otherwise. 

    The cassette chromosome will be the same as read chromosome; the cassette strand will be the same as read strand, 
     or opposite of the read strand if reads_are_reverse is True.

    The cassette position depends on read position, cassette strand (not read strand) and cassette_end in a complex way:
     Data I have:  which end of the insertion cassette the read is on, and which orientation the cassette is in. 
     Data I want:  the position of the base before and after the insertion, regardless of cassette orientation.
                       (the read orientation in regard to cassette doesn't matter at all here)
     If read is 5' of cassette and cassette is +, or read is 3' of cassette and cassette is -, read is BEFORE cassette
     If read is 3' of cassette and cassette is +, or read is 5' of cassette and cassette is -, read is AFTER cassette
      If read is before cassette, I care about the end of the read; if it's after, I care about the start)
      SAM alignment position is leftmost/rightmost, i.e. end is always the "later" position in the genome, 
       regardless of the read orientation, which gives me what I want, i.e. the insertion position.

    Insertion_position uses a 1-based position system (as opposed to HTSeq, which is 0-based).
    """
    ### chromosome is always the same as read (also checking that the HTSeq_pos has a chrom attribute at all here)
    try:
        chrom = HTSeq_pos.chrom
    except AttributeError:
        raise ValueError("Invalid position %s! Need an HTSeq iv object. (If empty, maybe read wasn't aligned?)"%HTSeq_pos)
    ### cassette strand is the same as read strand, OR the opposite if reads_are_reverse is True
    strand = HTSeq_pos.strand
    if reads_are_reverse:     strand = '+' if strand=='-' else '-'
    ### cassette position depends on the read position and cassette_end in a somewhat complex way 
    #   (see description in docstring, and ../notes.txt for even more detail)
    # HTSeq is 0-based and I want 1-based, thus the +1; end has no +1 because in HTSeq end is the base AFTER the alignment.
    if (cassette_end=='5prime' and strand=='+') or (cassette_end=='3prime' and strand=='-'):      
        pos_before, pos_after = HTSeq_pos.end, None
    elif (cassette_end=='3prime' and strand=='+') or (cassette_end=='5prime' and strand=='-'):    
        pos_before, pos_after = None, HTSeq_pos.start+1
    else:                           
        raise ValueError("cassette_end argument must be one of %s."%SEQ_ENDS)
    return Insertion_position(chrom, strand, pos_before, pos_after)


### Main classes describing the mutants and mutant sets

class Insertional_mutant_data():
    """ Data regarding a particular insertional mutant: insertion position, gene, read numbers/sequences, etc.

    Attributes:
     - position - an Insertion_position instance giving the insertion chromosome/strand/position, with ambiguity etc
     - gene, orientation, gene feature - what gene the insertion is in (or one of the SPECIAL_GENE_CODES if unknown), 
                whether it's in the sense or antisense orientation vs the gene, what feature (exon/intron/UTR) it's in.
     - total_read_count, perfect_read_count - number of all and perfectly aligned deepseq reads
     - unique_sequence_count, sequences_and_counts - number of unique read sequences, and a seq:count dictionary
    """

    def __init__(self, insertion_position):
        """ Set self.position based on argument; initialize read/sequence counts to 0 and gene-info to unknown. 
        insertion_position argument should be a Insertion_position instance. """
        self.position = insertion_position
        self.gene = SPECIAL_GENE_CODES.not_determined
        self.orientation = '?'
        self.gene_feature = '?'
        self.total_read_count = 0
        self.perfect_read_count = 0
        self.unique_sequence_count = 0
        self.sequences_and_counts = defaultdict(lambda: 0)

    # MAYBE-TODO give each mutant some kind of unique ID at some point in the process?  Or is genomic location sufficient?  If we end up using per-mutant barcodes (in addition to the flanking sequences), we could use that, probably, or that plus genomic location.

    def add_read(self, HTSeq_alignment, read_count=1, treat_unknown_as_match=False):
        """ Add a read to the data (or multiple identical reads, if read_count>1); return True if perfect match.
        Specifically: increment total_read_count, increment perfect_read_count if read is a perfect 
        alignment, increment the appropriate field of sequences_and_counts based on read sequence.
        Note: this does NOT check the read position to make sure it matches that of the object."""
        # MAYBE-TODO check HTSeq_alignment chromosome/strand to make sure it matches data in self?  Don't check position, that's more complicated (it can be either start or end) - could maybe check that position is within, idk, 10bp of either alignment start or alignment end?  Or not - I may want to cluster things in a non-position-based way anyway!  Hmmm...
        seq = HTSeq_alignment.read.seq
        # if it's a new sequence, increment unique_sequence_count; add a count to the self.sequences_and_counts dictionary.
        if seq not in self.sequences_and_counts:
            self.unique_sequence_count += 1
        self.sequences_and_counts[seq] += read_count
        # increment self.total_read_count; figure out if the read is perfect and increment self.perfect_read_count if yes.
        self.total_read_count += read_count
        treat_unknown_as = 'match' if treat_unknown_as_match else 'mutation'
        mutation_count = check_mutation_count_try_all_methods(HTSeq_alignment, treat_unknown_as=treat_unknown_as)
        if mutation_count==0:  
            self.perfect_read_count += read_count
            return True
        else:
            return False

    # LATER-TODO write a function to merge two instances together!  Merge their position (or just pick one position), add read counts together (should perfect reads from the wrong position still count as perfect though?), merge their sequences (may want to keep more data about sequences! Like exact position and number of mutations) (may want to store a list of HTSeq.alignment objects instead of just sequences+counts, really)

    def add_counts(self, total_count, perfect_count, sequence_variant_count, assume_new_sequences=False):
        """ Increment self.total_read_count, self.perfect_read_count and self.unique_sequence_count based on inputs.
        Note that ifself.unique_sequence_count>0, it's impossible to determine the correct new value: 
         if we had old data with one unique sequence and now we have new data with another one, how do we know
          if that's the same or different sequence?  The correct total could be 1 or 2, so it's an option:
         If assume_new_sequences is True, the total is old+new; if it's False, the total is max(old,new).
        """
        self.total_read_count += total_count
        self.perfect_read_count += perfect_count
        if assume_new_sequences:
            self.unique_sequence_count += sequence_variant_count
        else:
            self.unique_sequence_count = max(self.unique_sequence_count,sequence_variant_count)

    def add_sequence_and_counts(self, seq, seq_count, add_to_uniqseqcount=True):
        """ Add seq_count to self.sequences_and_counts[seq] (it's created with count 0 if seq wasn't a key before).
        Note: if add_to_uniqseqcount is False, this will never increment self.unique_sequence_count;
         otherwise it only does so if seq was not already present in the self.sequences_and_counts data
          and if the total number of sequences in self.sequences_and_counts is higher than self.unique_sequence_count. """
        if add_to_uniqseqcount:
            if seq not in self.sequences_and_counts and len(self.sequences_and_counts)>self.unique_sequence_count:
                self.unique_sequence_count += 1
        self.sequences_and_counts[seq] += seq_count

    def get_main_sequence(self, N=1):
        """ Return the most common sequence in this mutant and its count (or Nth most common sequence if N is provided)."""
        sequences_by_count = sorted([(count,seq) for (seq,count) in self.sequences_and_counts.iteritems()], reverse=True)
        # try returning the Nth sequence and count; return nothing if there are under N sequences.
        try:                return (sequences_by_count[N-1][1], sequences_by_count[N-1][0])
        except IndexError:  return ('',0)


class Insertional_mutant_library_dataset():
    """ A dataset of insertional mutants - contains some total counts and a set of Insertional_mutant_data objects.
    
    Attributes:
     - cassette_end - specifies which end of the insertion cassette the reads are on, and 
     - reads_are_reverse - True if the reads are in reverse orientation to the cassette, False otherwise
     - mutants_by_position - a (chrom,strand,pos):Insertional_mutant_data dictionary
     - discarded_read_count - number of reads discarded in preprocessing before alignment (not counted in total_read_count)
     - ignored_region_read_counts - region_name:read_count dictionary (not counted in total_read_count)
     - total_read_count, aligned_read_count, unaligned_read_count, perfect_read_count - various read counts, obvious
     - strand_read_counts, specific_region_read_counts - name:count dictionaries for strands and specific regions to track
     - mutants_in_genes, mutants_not_in_genes, mutants_undetermined, 
         mutants_sense, mutants_antisense - counts of mutants with various obvious properties
    """

    def __init__(self, cassette_end=None, reads_are_reverse=False):
        """ Saves the arguments as properties of the dataset; initializes an empty mutant dict; sets all counts to 0. """
         # make sure the arguments are valid values
        if not cassette_end in SEQ_ENDS+[None]: 
            raise ValueError("The cassette_end variable must be one of %s!"%SEQ_ENDS)
        self.cassette_end = cassette_end
        if not reads_are_reverse in [True,False]: 
            raise ValueError("The reads_are_reverse variable must be True or False!")
        self.reads_are_reverse = reads_are_reverse
        # MAYBE-TODO should reads_are_reverse be specified for the whole dataset, or just for each set of data added? Might be better to make it an option to add_alignment_reader_to_data and just switch the orientation of reads as they're added to the data, to make it possible to add both forward and reverse read sets to one Insertional_mutant_library_dataset dataset. - but then I'd have to keep track of (and print in outfile?) cassette_end and reads_are_reverse for every read instead of just keeping it once per dataset - complicated.
        # mutants_by_position is the main data structure here
        self.mutants_by_position = {}
        # various total read/mutant counts to keep track of
        self.discarded_read_count = 'unknown'
        self.ignored_region_read_counts = defaultdict(lambda: 0)
        self.total_read_count, self.aligned_read_count, self.unaligned_read_count, self.perfect_read_count = 0,0,0,0
        self.strand_read_counts = defaultdict(lambda: 0)
        self.specific_region_read_counts = defaultdict(lambda: 0)
        self.mutants_in_genes, self.mutants_not_in_genes, self.mutants_undetermined = 0,0,0
        self.mutants_sense, self.mutants_antisense = 0,0
    
    def add_discarded_reads(self, N, reset_count=False):
        """ Add N to self.discarded_read_count (or set self.discarded_read_count to N if reset_count is True). """
        if reset_count or self.discarded_read_count=='unknown':
            self.discarded_read_count = int(N)
        else:
            self.discarded_read_count += int(N)

    def add_alignment_reader_to_data(self, HTSeq_alignment_reader, uncollapse_read_counts=False, 
                                     treat_unknown_as_match=False, chromosomes_to_count=[], chromosomes_to_ignore=[]):
        """ Adds all alignments from the reader to the mutant data; currently based only on position, but that may change. 

        Input must be a list/generator/etc of HTSeq.Alignment objects (usually an HTSeq.SAM_Reader).
        Set uncollapse_read_counts to True if the original deepseq data was collapsed to unique sequences using
         fastx_uncollapser before alignment, to get the correct original read counts.
        Treat_unknown_as_match governs whether alignments with no detailed information are treated as perfect or not.
        Chromosomes_to_count is a list of chromosomes that should have aligned read counts kept and added to the header 
         summary (they're treated normally otherwise); reads that align to a chromosome in the chromosomes_to_ignore list 
         will be ignored in the data (but not the total counts contained in the header). 
        """

        if self.cassette_end is None:
            raise Exception("Cannot add data from an alignment reader if cassette_end isn't specified! Please set the "
                +"cassette_end attribute of this Insertional_mutant_library_dataset instance to one of %s first."%SEQ_ENDS)
        for aln in HTSeq_alignment_reader:
            if uncollapse_read_counts:      read_count = get_seq_count_from_collapsed_header(aln.read.name)
            else:                           read_count = 1
            self.total_read_count += read_count
            # if read is unaligned, add to unaligned count and skip to the next read
            if (not aln.aligned) or (aln.iv is None):
                self.unaligned_read_count += read_count
                continue
            # get the cassette insertion position (as an Insertion_position object)
            insertion_pos = get_insertion_pos_from_HTSeq_read_pos(aln.iv, self.cassette_end, self.reads_are_reverse)
            chrom = insertion_pos.chromosome
            strand = insertion_pos.strand
            pos = insertion_pos.min_position
            # if read is aligned to one of the chromosomes_to_ignore, add to the right count and skip to the next read
            if chrom in chromosomes_to_ignore:
                self.ignored_region_read_counts[chrom] += read_count
                continue
            # if read is aligned to anything else, add to aligned count, strand counts etc
            self.aligned_read_count += read_count
            self.strand_read_counts[strand] += read_count
            # MAYBE-TODO do I want info on how many reads were aligned to which strand for the chromosomes_to_count or even all chromosomes?  Maybe optionally...  And how many were perfect, and how many mutants there were... Might want to write a separate class or function just for this.  If so, should output it in a tabular format, with all the different data (reads, +, -, perfect, ...) printed tab-separated in one row.
            if chrom in chromosomes_to_count:
                self.specific_region_read_counts[chrom] += read_count
            # check if there's already a mutant at that position; if not, make a new one
            if (chrom,strand,pos) not in self.mutants_by_position.keys():
                # LATER-TODO may want to check whether the read should be added to another mutant before making a new one,
                #  for example if it's 1bp away from an existing one?  Or just do all those group-merge checks at the end.
                self.mutants_by_position[(chrom,strand,pos)] = Insertional_mutant_data(insertion_pos)
            # add_read adds the read to the full data; also returns True if alignment was perfect, to add to perfect_count
            if self.mutants_by_position[(chrom,strand,pos)].add_read(aln, read_count, treat_unknown_as_match):
                self.perfect_read_count += read_count
        # LATER-TODO at this point, may want to go over the full list of mutants and see if any of them should be merged (for example because they're only 1bp apart and one of them has only one read and the other has thousands), or have issues (like are too close together, or have more imperfect than perfect reads, or something) - or maybe that should be a separate function?

    def add_gene_positions_to_data(self, genefile, detailed_features=False, gene_info_file=None, 
                                   liberal_position_test=False, known_bad_chromosomes=[]):
        """ Look up gene positions for each mutant using genefile and add to data; 
        if detailed_features is True, also look up whether the mutant is in an exon/intron/UTR (NOT IMPLEMENTED); 
        if gene_info_file is not None, use it to get gene names/descriptions/other info as well (NOT IMPLEMENTED).
        If liberal_position_test is False, the insertion position must definitely be inside the gene; 
         if True, it's sufficient that is may be inside or bordering the gene (depending on ambiguity).
        """ 
        # parse the genefile reference using BCBio.GFF - first ONLY look at "gene" features
        reference_by_chromosome = parse_gene_pos_file(genefile)
        # how to tell whether pos is inside gene - pick a (liberal or strict) function from DNA_basic_utilities
        if liberal_position_test:   position_test_function = position_test_overlap
        else:                       position_test_function = position_test_contains
        # go over all mutants, and figure out which gene they're in (if any), keep track of totals
        for mutant in self.mutants_by_position.itervalues():
            gene_ID, orientation = find_gene_by_pos(mutant.position, reference_by_chromosome, 
                                                    position_test_function, known_bad_chromosomes)
            mutant.gene = gene_ID
            mutant.orientation = orientation
            # TODO in addition to gene ID and orientation, we want detailed feature location (exon/intron/UTR) (OPTIONAL)
            # LATER-TODO we also want gene name/description/stuff from gene_info_file, if given! Currently not implemented.  Should probably only use gene name in the line-per-mutant output, and only add other gene info (description etc) to the line-per-gene output.
            if gene_ID==SPECIAL_GENE_CODES.chromosome_not_in_reference:     self.mutants_undetermined += 1
            elif gene_ID==SPECIAL_GENE_CODES.not_found:                     self.mutants_not_in_genes += 1
            else:                                                           self.mutants_in_genes += 1
            if orientation=='sense':                self.mutants_sense += 1
            elif orientation=='antisense':          self.mutants_antisense += 1
        # LATER-TODO add a run-test case for this!

    def find_most_common_mutant(self):
        """ Return the Insertional_mutant_data object from self.mutants_by_position with the most total reads."""
        current_readcount = 0
        current_mutant = None
        for mutant in self.mutants_by_position.itervalues():
            if mutant.total_read_count > current_readcount:
                current_readcount = mutant.total_read_count
                current_mutant = mutant
        return current_mutant

    def print_summary(self, OUTPUT=sys.stdout, line_prefix='    ', header_prefix=' * '):
        """ Print basic read and mutant counts (prints to stdout by default, can also pass an open file object)."""
        OUTPUT.write(line_prefix+"Reads discarded in preprocessing: %s\n"%(self.discarded_read_count))
        OUTPUT.write(header_prefix+"Total reads processed: %s\n"%(self.total_read_count))
        OUTPUT.write(line_prefix+"Unaligned reads: %s\n"%(self.unaligned_read_count))
        for (region,count) in self.ignored_region_read_counts.iteritems():
            OUTPUT.write(line_prefix+"Discarded reads aligned to %s: %s\n"%(region, count))
        OUTPUT.write(line_prefix+"Aligned reads (non-discarded): %s\n"%(self.aligned_read_count))
        OUTPUT.write(line_prefix+"Perfectly aligned reads (no mismatches): %s\n"%(self.perfect_read_count))
        for (strand,count) in self.strand_read_counts.iteritems():
            OUTPUT.write(line_prefix+"Reads with insertion direction matching chromosome %s strand: %s\n"%(strand, count))
        for (region,count) in self.specific_region_read_counts.iteritems():
            OUTPUT.write(line_prefix+"Reads aligned to %s: %s\n"%(region, count))
        # MAYBE-TODO add percentages of total (or aligned) reads to all of these numbers in addition to raw counts!
        # MAYBE-TODO keep track of the count of separate mutants in each category, as well as total read counts?
        OUTPUT.write(header_prefix+"Distinct mutants (read groups) by cassette insertion position: %s\n"%\
                                                                                     (len(self.mutants_by_position)))
        OUTPUT.write(line_prefix+"(read is at %s end of cassette, in %s direction to cassette)\n"%(self.cassette_end, 
                                                                    ('reverse' if self.reads_are_reverse else 'forward')))
        g = self.find_most_common_mutant()
        OUTPUT.write(line_prefix+"Most common mutant: %s, position %s, %s strand:"%(g.position.chromosome,
                                                                           g.position.full_position, g.position.strand))
        OUTPUT.write(" %s reads (%.0f%% of aligned)\n"%(g.total_read_count, 
                                                        100.0*g.total_read_count/self.aligned_read_count))
        # MAYBE-TODO may also be a good idea to keep track of the most common SEQUENCE, not just mutant...
        # print the gene annotation info, but only if there is any
        if self.mutants_in_genes + self.mutants_not_in_genes + self.mutants_undetermined:
            OUTPUT.write(line_prefix+"Mutant cassettes inside genes: %s\n"%(self.mutants_in_genes))
            OUTPUT.write(line_prefix+"Mutant cassettes not inside genes: %s\n"%(self.mutants_not_in_genes))
            OUTPUT.write(line_prefix+"Mutant cassettes in unknown chromosomes: %s\n"%(self.mutants_undetermined))
            OUTPUT.write(line_prefix+"Mutant cassettes in sense orientation to gene: %s\n"%(self.mutants_sense))
            OUTPUT.write(line_prefix+"Mutant cassettes in antisense orientation to gene: %s\n"%(self.mutants_antisense))
            all_genes = set([m.gene for m in self.mutants_by_position.values()]) - set(SPECIAL_GENE_CODES.all_codes)
            OUTPUT.write(line_prefix+"Genes containing at least one mutant: %s\n"%(len(all_genes)))
            # LATER-TODO Add count of genes containing at least two mutants! Once I have a per-gene view of the data.

    def print_data(self, OUTPUT=None, sort_data=False, N_sequences=2, header_line=True, header_prefix="# "):
        """ Print full data, one line per mutant: position data, gene info, read counts, optionally sequences.
        (see the file header line for exactly what all the output fields are).

        If N_sequences<1, only prints position (chromosome and position), total and perfect read count, 
          and the number of sequence variants.  If N_sequences==1, also prints the most common sequence and count; 
          if N_sequences>1, adds the second most common sequence and count, and so on.
        Output is tab-separated, with headers starting with "# ".  Prints to an open file object (stdout by default).
        """
        # MAYBE-TODO should printing the gene info be optional?  Maybe... Would save space when there isn't any meaningful gene info to print anyway.
        if OUTPUT is None:
            OUTPUT = sys.stdout

        if header_line:
            headers = ['chromosome','strand','min_position','full_position', 'gene','orientation','feature',
                       'total_reads','perfect_reads', 'N_sequence_variants']
            for N in range(1,N_sequences+1):
                headers.extend(['read_sequence_%s'%N,'seq_%s_count'%N])
            OUTPUT.write(header_prefix + '\t'.join(headers) + "\n")

        if sort_data:
            data = sorted(self.mutants_by_position.values(), key = lambda x: x.position)
            # x.position here is an Insertion_position object and has a sensible cmp function
        else:
            data = self.mutants_by_position.itervalues()

        for mutant in data:
            mutant_data = [mutant.position.chromosome, mutant.position.strand, mutant.position.min_position, 
                           mutant.position.full_position, mutant.gene, mutant.orientation, mutant.gene_feature, 
                           mutant.total_read_count, mutant.perfect_read_count, mutant.unique_sequence_count]
            OUTPUT.write('\t'.join([str(x) for x in mutant_data]))
            for N in range(1,N_sequences+1):
                OUTPUT.write('\t%s\t%s'%mutant.get_main_sequence(N))
                # MAYBE-TODO also give the length and number of mutations for each sequence? Optionally?  Length is easy, but do I even keep track of mutation number?  I probably should...
            OUTPUT.write('\n')

    def read_from_file(self, infile, assume_new_sequences=False):
        """ Read data from a file generated by self.print_data, and add to self.mutants_by_position.  
        Note that if you read data from a file and add it to data that already exists, it's impossible to determine the 
         correct number of unique sequence variants per mutant: if the data originally listed 1 unique sequence, and new
          data read from a file adds another 2 sequences, is that a total of 2 or 3 unique sequences? 
         If assume_new_sequences is True, the total is old+new; if it's False, the total is max(old,new).
        Currently doesn't read the specific sequences and counts - even if it did, some information could 
        always be missing, since the file only has N first sequences. """
        # NOTE: this function is half-finished, really (basic functionality fine but things missing, see MAYBE-TODOs), and I'm not sure it's actually going to be necessary after some more rewrites, or in what form, so I'm leaving it as is for the moment.  It has a unit-test but I turned it off (by renaming it from test_ to notest_) because right now I don't care that it fails.
        for line in open(infile):
            # LATER-TODO get unaligned/discarded/etc read count from summary, so we can keep track of full counts!
            # ignore comment and header lines
            if line.startswith('#'):    continue
            if line.startswith('chromosome\tstrand\tposition\t'):    continue
            fields = line.split('\t')
            chromosome = fields[0]
            strand = fields[1]
            pos = int(fields[2])
            gene = fields[3]
            orientation = fields[4]
            gene_feature = fields[5]
            total_reads,perfect_reads,sequence_variants = [int(x) for x in fields[6:9]]
            self.mutants_by_position[(chromosome,strand,pos)].add_counts(total_reads, perfect_reads, 
                                                                           sequence_variants, assume_new_sequences)
            self.mutants_by_position[(chromosome,strand,pos)].gene = gene
            self.mutants_by_position[(chromosome,strand,pos)].orientation = orientation
            self.mutants_by_position[(chromosome,strand,pos)].gene_feature = gene_feature
            # MAYBE-TODO split the remaining fields into twos (seq,count) (we don't know how many there will be) 
            #   and use self.mutants_by_position[(chromosome, position)].add_sequence_and_counts(seq,count) 
            #   to add specific sequences and counts to the data.  Add to unit-test!
        self.aligned_read_count = sum([x.total_read_count for x in self.mutants_by_position.values()])
        self.total_read_count = self.aligned_read_count + self.unaligned_read_count
    
# MAYBE-TODO I think later I'll want another way of organizing Insertional_mutant_data objects - by gene, or by chromosome instead of chromosome+position, or such... don't get too stuck on Insertional_mutant_library_dataset!  Or I could just add other mutant-organization dictionaries/views to the same class, that might be better really...

# LATER-TODO at some point I'll probably want to generalize both of those classes to not necessarily be grouped by position...
# LATER-TODO Hmmm, do I REALLY need my main data type to be a dictionary by position, or could it just be a set? Do I ever look anything up in this dictionary??  Oh, yeah, I do, when adding new reads that were aligned to the same position as some other reads.  But if I did clustering earlier, that would stop being an issue... And if I want to take adjacent mutants and merge them together, the position-based key will stop being very meaningful anyway... Hmmmm. May need a more complicated method. For now, could have the dict key be precise alignment chrom/pos/strand, but have a full position object in the mutant object. 
# Okay, so how SHOULD I do the clustering?  Two basic options here: either cluster all the reads FIRST and THEN organize them into Insertional_mutant_data objects, or just keep a set of Insertional_mutant_data objects and whenever a new read is added, run a function on the new read and the existing set to find which one to add it to.  THIS IS COMPLICATED, I DON'T KNOW IF I SHOULD BE DOING IT RIGHT NOW... Try to implement something very simple that I can expand later?



######### Test code #########

class Testing_single_functions(unittest.TestCase):
    """ Unit-tests for most of the top-level functions in this module. """

    class Fake_pos:
        def __init__(self, chrom, strand, start, end):
            self.chrom = chrom
            self.strand = strand
            self.start = start
            self.end = end

    def test__make_joint_position(self):
        assert make_joint_position(None) == None
        for arg in ['', [], {}, 'aaa', True, False]:
            self.assertRaises(ValueError, make_joint_position, arg)
        assert make_joint_position(100) == SeqFeature.ExactPosition(100)
        assert make_joint_position([100,100]) == SeqFeature.ExactPosition(100)
        assert make_joint_position([100,103]) == SeqFeature.WithinPosition(100,3)
        assert make_joint_position([100,103,102,102,101]) == SeqFeature.WithinPosition(100,3)

    def test__get_insertion_pos_from_HTSeq_position(self):
        # should raise exception for invalid HTSeq_pos argument
        for bad_HTSeq_pos in [None, '', 'aaa', 0, 1, 0.65, [], {}, True, False]:
            for cassette_end in SEQ_ENDS:
                self.assertRaises(ValueError, get_insertion_pos_from_HTSeq_read_pos, None, cassette_end)
        # should raise exception for invalid cassette_end
        fake_pos = self.Fake_pos('C', '+', 0, 5)
        for bad_cassette_end in ['','aaa',0,1,[],{},None,True,False,'start','end','middle','read','leftmost','rightmost']:
            self.assertRaises(ValueError, get_insertion_pos_from_HTSeq_read_pos, fake_pos, bad_cassette_end)
        ### testing normal functionality: should return an Insertion_position instance with the same chromosome, 
        #    and strand/position depending on the arguments in a somewhat complicated way.
        ## a few spot-checks outside the loop 
        #   (based on the example at the end of "Possible read sides/directions" section in ../notes.txt)
        # remember HTSeq position is 0-based and end-exclusive, and the position I want is 1-based end-inclusive!  
        #  So in the end the two relevant 1-based numbers end up being the same as the 0-based positions,
        #  because in the case of the start, min_position is actually start-1, and in the case of the end, we're adding 1
        #  to switch from 0-based to 1-based but then subtracting 1 to make the end the last base instead of the base after
        fake_pos_plus = self.Fake_pos('C', '+', 3, 7)
        fake_pos_minus = self.Fake_pos('C', '-', 3, 7)
        assert get_insertion_pos_from_HTSeq_read_pos(fake_pos_plus, '5prime',reads_are_reverse=False).min_position == 7
        assert get_insertion_pos_from_HTSeq_read_pos(fake_pos_plus, '3prime',reads_are_reverse=False).min_position == 3
        assert get_insertion_pos_from_HTSeq_read_pos(fake_pos_minus,'5prime',reads_are_reverse=True ).min_position == 7
        assert get_insertion_pos_from_HTSeq_read_pos(fake_pos_minus,'3prime',reads_are_reverse=True ).min_position == 3
        assert get_insertion_pos_from_HTSeq_read_pos(fake_pos_plus, '5prime',reads_are_reverse=True ).min_position == 3
        assert get_insertion_pos_from_HTSeq_read_pos(fake_pos_plus, '3prime',reads_are_reverse=True ).min_position == 7
        assert get_insertion_pos_from_HTSeq_read_pos(fake_pos_minus,'5prime',reads_are_reverse=False).min_position == 3
        assert get_insertion_pos_from_HTSeq_read_pos(fake_pos_minus,'3prime',reads_are_reverse=False).min_position == 7
        # more checks in a loop - see above for what we expect!
        for (strand_in, if_reverse, strand_out) in [('+',False,'+'), ('-',False,'-'), ('+',True,'-'), ('-',True,'+')]:
            for (start,end) in [(0,5), (0,100), (10,11), (5,44)]:
                fake_pos = self.Fake_pos('C', strand_in, start, end)
                result_5prime = get_insertion_pos_from_HTSeq_read_pos(fake_pos, '5prime', if_reverse)
                result_3prime = get_insertion_pos_from_HTSeq_read_pos(fake_pos, '3prime', if_reverse)
                assert result_5prime.chromosome == result_3prime.chromosome == 'C'
                assert result_5prime.strand == result_3prime.strand == strand_out
                if strand_out=='+':
                    assert result_5prime.min_position == end
                    assert result_3prime.min_position == start
                elif strand_out=='-':
                    assert result_5prime.min_position == start
                    assert result_3prime.min_position == end


class Testing_Insertional_mutant_data(unittest.TestCase):
    """ Unit-tests for the Insertional_mutant_data class and its methods. """

    def test__init(self):
        for chromosome in ['chr1', 'chromosome_2', 'chrom3', 'a', 'adfads', '100', 'scaffold_88']:
            for strand in ['+','-']:
                for position in [1,2,5,100,10000,4323423]:
                    ins_pos_5prime = Insertion_position(chromosome,strand,position_before=position)
                    ins_pos_3prime = Insertion_position(chromosome,strand,position_after=position)
                    mutant_5prime = Insertional_mutant_data(ins_pos_5prime)
                    mutant_3prime = Insertional_mutant_data(ins_pos_3prime)
                    assert mutant_5prime.position.min_position == position
                    assert mutant_3prime.position.min_position == position-1
                    assert mutant_5prime.position.max_position == position+1
                    assert mutant_3prime.position.max_position == position
                    assert mutant_5prime.position.full_position == "%s-?"%(position)
                    assert mutant_3prime.position.full_position == "?-%s"%position
                    for mutant in [mutant_5prime,mutant_3prime]:
                        assert mutant.position.chromosome == chromosome
                        assert mutant.position.strand == strand
                        assert mutant.gene == SPECIAL_GENE_CODES.not_determined
                        assert mutant.orientation == '?'
                        assert mutant.gene_feature == '?'
                        assert mutant.total_read_count == 0
                        assert mutant.perfect_read_count == 0
                        assert mutant.unique_sequence_count == 0
                        assert mutant.sequences_and_counts == {}

    def test__add_read(self):
        pass
        # MAYBE-TODO implement using a mock-up of HTSeq_alignment?  (see Testing_single_functions for how I did that)

    def test__add_counts(self):
        mutant = Insertional_mutant_data(Insertion_position('chr','+',3))
        mutant.add_counts(0,0,0)
        assert mutant.total_read_count == 0
        assert mutant.perfect_read_count == 0
        assert mutant.sequences_and_counts == {}
        mutant.add_counts(2,2,1)
        assert mutant.total_read_count == 2
        assert mutant.perfect_read_count == 2
        assert mutant.sequences_and_counts == {}
        mutant.add_counts(2,1,1)
        assert mutant.total_read_count == 4
        assert mutant.perfect_read_count == 3
        assert mutant.sequences_and_counts == {}
        # how mutant.unique_sequence_count changes depends on assume_new_sequences:
        #  - if False, mutant.unique_sequence_count is max(new_seq_count, mutant.unique_sequence_count)
        mutant = Insertional_mutant_data(Insertion_position('chr','+',3))
        mutant.add_counts(0,0,0,assume_new_sequences=False)
        assert mutant.unique_sequence_count == 0
        mutant.add_counts(1,1,1,assume_new_sequences=False)
        assert mutant.unique_sequence_count == 1
        mutant.add_counts(2,2,2,assume_new_sequences=False)
        assert mutant.unique_sequence_count == 2
        mutant.add_counts(1,1,1,assume_new_sequences=False)
        assert mutant.unique_sequence_count == 2
        mutant.add_counts(2,2,2,assume_new_sequences=False)
        assert mutant.unique_sequence_count == 2
        #  - if True and mutant.unique_sequence_count is new_seq_count + mutant.unique_sequence_count
        mutant = Insertional_mutant_data(Insertion_position('chr','+',3))
        mutant.add_counts(0,0,0,assume_new_sequences=True)
        assert mutant.unique_sequence_count == 0
        mutant.add_counts(1,1,1,assume_new_sequences=True)
        assert mutant.unique_sequence_count == 1
        mutant.add_counts(2,2,2,assume_new_sequences=True)
        assert mutant.unique_sequence_count == 3
        mutant.add_counts(1,1,1,assume_new_sequences=True)
        assert mutant.unique_sequence_count == 4
        mutant.add_counts(2,2,2,assume_new_sequences=True)
        assert mutant.unique_sequence_count == 6
        mutant.add_counts(2,2,2,assume_new_sequences=False)
        assert mutant.unique_sequence_count == 6

    def test__add_sequence_and_counts(self):
        mutant = Insertional_mutant_data(Insertion_position('chr','+',3))
        # adding sequence/count to mutant.sequences_and_counts, WITHOUT touching mutant.unique_sequence_count
        mutant.add_sequence_and_counts('AAA',2,add_to_uniqseqcount=False)
        assert mutant.sequences_and_counts == {'AAA':2}
        assert mutant.unique_sequence_count == 0
        # adding sequence/count to mutant.sequences_and_counts, and incrementing mutant.unique_sequence_count if warranted:
        #  - if adding a sequence that was already there, don't increment
        mutant.add_sequence_and_counts('AAA',2,add_to_uniqseqcount=True)
        assert mutant.sequences_and_counts == {'AAA':4}
        assert mutant.unique_sequence_count == 0
        #  - if adding a new sequence, increment
        mutant.add_sequence_and_counts('GGG',2,add_to_uniqseqcount=True)
        assert mutant.sequences_and_counts == {'AAA':4, 'GGG':2}
        assert mutant.unique_sequence_count == 1
        #  - if adding a new sequence but mutant.unique_sequence_count is already higher than expected, don't increment
        mutant.unique_sequence_count = 5
        mutant.add_sequence_and_counts('CCC',2,add_to_uniqseqcount=True)
        assert mutant.sequences_and_counts == {'AAA':4, 'GGG':2, 'CCC':2}
        assert mutant.unique_sequence_count == 5
        # make sure it raises an error if given a non-numeric argument
        for not_a_number in [None,'','a','GGG']:
            self.assertRaises(TypeError,mutant.add_sequence_and_counts,'CCC',not_a_number)

    def test__get_main_sequence(self):
        mutant = Insertional_mutant_data(Insertion_position('chr','+',3))
        assert mutant.get_main_sequence() == ('',0)
        assert mutant.get_main_sequence(1) == ('',0)
        assert mutant.get_main_sequence(4) == ('',0)
        mutant.add_sequence_and_counts('AAA',1)
        mutant.add_sequence_and_counts('GGG',2)
        assert mutant.sequences_and_counts == {'AAA':1, 'GGG':2}
        assert mutant.get_main_sequence() == ('GGG',2)
        assert mutant.get_main_sequence(1) == ('GGG',2)
        assert mutant.get_main_sequence(2) == ('AAA',1)
        assert mutant.get_main_sequence(3) == ('',0)
        assert mutant.get_main_sequence(4) == ('',0)
        mutant.add_sequence_and_counts('CCC',1)
        mutant.add_sequence_and_counts('AAA',2)
        assert mutant.sequences_and_counts == {'AAA':3, 'GGG':2, 'CCC':1}
        assert mutant.get_main_sequence() == ('AAA',3)
        assert mutant.get_main_sequence(1) == ('AAA',3)
        assert mutant.get_main_sequence(2) == ('GGG',2)
        assert mutant.get_main_sequence(3) == ('CCC',1)
        assert mutant.get_main_sequence(4) == ('',0)
        assert mutant.get_main_sequence(5) == ('',0)


class Testing_Insertional_mutant_library_dataset(unittest.TestCase):
    """ Unit-tests for the Insertional_mutant_library_dataset class and its methods. """

    def test__init(self):
        for cassette_end in SEQ_ENDS+[None]:
            data = Insertional_mutant_library_dataset(cassette_end)
            assert data.cassette_end == cassette_end
            assert data.mutants_by_position == {}
            assert data.total_read_count == 0
            assert data.aligned_read_count == 0
            assert data.unaligned_read_count == 0
        for cassette_end in [True, False, 0, 0.11, 23, 'asdfas', '', 'something', [2,1]]:
            self.assertRaises(ValueError, Insertional_mutant_library_dataset, cassette_end)
        # LATER-TODO rewrite this to add new args/features

    # LATER-TODO add unit-test for add_discarded_reads, add_gene_positions_to_data, find_most_common_mutant, 

    def test__add_alignment_reader_to_data(self):
        pass
        # MAYBE-TODO implement using a mock-up of HTSeq_alignment?  (see Testing_single_functions for how I did that)
        #   make sure it fails if self.cassette_end isn't defined...

    def test__print_summary(self):
        pass
        # MAYBE-TODO implement based on stuff in test_data, like do_test_run in deepseq_count_alignments.py?

    def test__print_data(self):
        pass
        # MAYBE-TODO implement based on stuff in test_data, like do_test_run in deepseq_count_alignments.py?

    def no_test__read_from_file(self):
        input_file = 'test_data/test_output__leftmost.txt'
        data = Insertional_mutant_library_dataset(None)
        data.read_from_file(input_file)
        assert data.aligned_read_count == 30
        assert data.unaligned_read_count == 0
        assert data.total_read_count == 30
        # just spot-checking some of the outputs
        mutant = data.mutants_by_position[('reads_2_seqs_1','+',199)]
        assert mutant.chromosome == 'reads_2_seqs_1'
        assert mutant.position == 199
        assert mutant.total_read_count == 2
        assert mutant.perfect_read_count == 2 
        assert mutant.unique_sequence_count == 1
        mutant = data.mutants_by_position[('mutation_yes','+',199)]
        assert mutant.chromosome == 'mutation_yes'
        assert mutant.position == 199
        assert mutant.total_read_count == 6
        assert mutant.perfect_read_count == 0
        assert mutant.unique_sequence_count == 1
        mutant = data.mutants_by_position[('strandedness_+_reference','+',99)]
        assert mutant.chromosome == 'strandedness_+_reference'
        assert mutant.position == 99
        assert mutant.total_read_count == 1
        assert mutant.perfect_read_count == 1
        assert mutant.unique_sequence_count == 1
        # try adding more data to a file that already has some...
        data.read_from_file(input_file, assume_new_sequences=False)
        mutant = data.mutants_by_position[('reads_2_seqs_1','+',199)]
        assert mutant.chromosome == 'reads_2_seqs_1'
        assert mutant.position == 199
        assert mutant.total_read_count == 4
        assert mutant.perfect_read_count == 4
        # how mutant.unique_sequence_count should act in this case depends on the value of assume_new_sequences
        assert mutant.unique_sequence_count == 1
        data.read_from_file(input_file, assume_new_sequences=True)
        assert mutant.unique_sequence_count == 2


if __name__ == "__main__":
    """ Allows both running and importing of this file. """
    print("*** This is a module to be imported to other files - running the built-in test suite. ***")
    unittest.main(argv=[sys.argv[0]])
    # if I wanted more control I could do this instead:
    #import os
    #unittest.TextTestRunner(verbosity=1).run(unittest.defaultTestLoader.loadTestsFromName(os.path.splitext(sys.argv[0])[0]))
    #   (autodetection of all tests - see http://docs.python.org/library/unittest.html#unittest.TestLoader)
    # there's probably also some way to easily get all tests from the current file without passing the name, but I haven't found it yet...

