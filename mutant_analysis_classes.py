#!/usr/bin/env python
"""
Module containing functions and classes useful for parsing deepseq SAM files and other deepseq data analysis we're doing.

This is a module to be imported and used by other programs.  Running it directly runs the built-in test suite.

 -- Weronika Patena, Jonikas Lab, Carnegie Institution, 2011
"""

# basic libraries
import sys, re
import unittest
from collections import defaultdict
# other libraries
import HTSeq
from BCBio import GFF
from Bio import SeqFeature
# my modules
from DNA_basic_utilities import SEQ_ENDS, SEQ_STRANDS, SEQ_DIRECTIONS, SEQ_ORIENTATIONS, position_test_contains, position_test_overlap
from deepseq_utilities import get_seq_count_from_collapsed_header, check_mutation_count_try_all_methods


class SPECIAL_GENE_CODES(object):
    not_determined = "gene_unknown"
    chromosome_not_in_reference = "unknown_chrom"
    not_found = "no_gene_found"
# it seems like I have to set SPECIAL_GENE_CODES.all_codes afterward because I can't access __dict__ from inside the class
SPECIAL_GENE_CODES.all_codes = [value for (name,value) in SPECIAL_GENE_CODES.__dict__.items() if not name.startswith('__')]


### Various functions

# MAYBE-TODO these could probably go in basic_programs/deepseq_utilities or something...

def parse_gene_pos_file(genefile):
    """ Parse a gff file using the GFF class from BCBio; return a chromosome:data dictionary."""
    # LATER-TODO add some options to specify the limits?  Sometimes I will want intron/exon/UTR and not just gene...  And sometimes I may want to do this by chromosome instead of all at once to not use too much memory?
    genefile_parsing_limits = {'gff_type': ['gene']}
    reference_by_chromosome = {}
    with open(genefile) as GENEFILE:
        for record in GFF.parse(GENEFILE, limit_info=genefile_parsing_limits):
            #if options.verbose:   print "\tparsing %s..."%record.id
            reference_by_chromosome[record.id] = record
    # For checking various things in the gff file that are unrelated to mutant-location, see gff_examine_file.py
    return reference_by_chromosome
    # MAYBE-TODO add unit test?  Not sure if worth it, it's only a wrapper around BCBio.GFF, and would need a lot of fake data/files to test properly.

def find_gene_by_pos(position_data, reference_by_chromosome, position_test_function, 
                     chromosomes_seen_already=set(), error_for_tests=False):
    """ If the location given by chromosome/position is inside a gene, return geneID and orientation vs strand argument; 
    otherwise return ('no_gene_found', '') or ('unknown_chrom','').
    Gets gene locations from reference_by_chromosome - a chrom:record dict, with records generated by BCBio.GFF parser. 
    Position_test_function is a function that takes gene_start,gene_end,pos_start,pos_end and returns True if pos in gene.
    Chromosomes_seen_already is a list used to store data between function runs, in order to suppress repeated warnings 
     about chromosome names absent in reference_by_chromosome. A pre-populated list can be passed if desired.
    """
    # see notes_on_GFF_parsing.txt for what a GFF record (reference_by_chromosome[chromosome]) will be like
    assert position_data.strand in ['+','-'], "Strand should be %s, and is %s!"%(' or '.join(SEQ_STRANDS),strand)
    # fail gracefully when you see an unexpected "chromosome"; keep track in order to only print the warning once
    if not position_data.chromosome in reference_by_chromosome.keys():
        if not position_data.chromosome in chromosomes_seen_already:
            # Normally I want printing, but when running tests it's hard to test printing, so adding an exception option
            info = 'Warning: chromosome "%s" not found in genefile data! (No further warnings will be shown)'%(chromosome)
            if error_for_tests:     raise ValueError(info)
            else:                   print(info)
        chromosomes_seen_already.add(position_data.chromosome)
        return SPECIAL_GENE_CODES.chromosome_not_in_reference, '?'
    # if the chromosome is in the record, go over all the genes in it and look for one that matches the position
    #   (using position_test_function, which was passed as an argument - it can be more or less strict)
    for gene in reference_by_chromosome[position_data.chromosome].features:
        if position_test_function(gene.location.start.position, gene.location.end.position, 
                                  position_data.min_position, position_data.max_position):
            if gene.strand==1:      orientation = 'sense' if position_data.strand=='+' else 'antisense'
            elif gene.strand==-1:   orientation = 'sense' if position_data.strand=='-' else 'antisense'
            else:                   orientation = '?'
            return gene.id, orientation
    return SPECIAL_GENE_CODES.not_found, '?'
    # MAYBE-TODO add unit test?


### Functions/classes for dealing with alignment/insertion positions

def make_joint_position(val_or_list):
    """ Takes a number or an iterator of numbers; returns biopython ExactPosition(val) or WithinPosition(min,max-min). """
    # Do I even need this SeqFeature.ExactPosition/SeqFeature.WithinPosition thing from biopython here?  
    #   I might as well use them, I guess, but I could write something of my own too.
    if val_or_list is None:         
        return None
    if (val_or_list is True) or (val_or_list is False): 
        raise ValueError("Argument to make_joint_position can't be True/False!")
    try:
        min_val = int(min(val_or_list))
        max_val = int(max(val_or_list))
        if min_val==max_val:    return SeqFeature.ExactPosition(min_val)
        else:                   return SeqFeature.WithinPosition(min_val, min_val-max_val)
    except TypeError:           return SeqFeature.ExactPosition(int(val_or_list))


class Insertion_position():
    """ A descriptor of the position of a genomic insertion, with handling of before/after sides and ambiguity.

    See the __init__ docstring for how position initialization works.
    
    Attributes: 
     - chromosome and strand - self-explanatory.
     - position_before and position_after - biopython SeqFeature.<SomeType>Position objects
     - min_position and max_position - lowest/highest possible position values as plain numbers
     - full_position - a string describing the full position in biopython SeqFeature.FeatureLocation format
     - chromosome_name, chromosome_number - two parts of chromosome: 'chr1'->('chr','1'), 'abc'->('abc','')
     - all_position_values - all sorting-relevant information: chrome name, number, min_position, max_position, strand

    Methods: 
     - printing: __str__ returns full_position
     - comparison: __cmp__ is based on all_position_values 
    """

    def __init__(self, chromosome, strand, position_before=None, position_after=None):
        """ Initialize all the values - dealing with positions is a bit complicated. 
        
        The two position_* arguments can be numbers, or iterators of numbers interpreted as a range of positions, 
         from which a min and max value is taken. 
        If only one of the position_* arguments is provided, the other is inferred based on the assumption that 
         before<after, using the biopython AfterPosition/BeforePosition classes to make the uncertainty clear.
        """
        if (position_before is None) and (position_after is None):
            raise ValueError("can't create an Insertion_position object with no known position values!")
        self.chromosome = chromosome
        self.strand = strand
        self.position_before = make_joint_position(position_before)
        self.position_after = make_joint_position(position_after)
        ### non-obvious position descriptors
        if self.position_after is None:
            self.min_position = self.position_before.position
            self.max_position = self.position_before.position+1
        elif self.position_before is None:
            self.min_position = self.position_after.position-1
            self.max_position = self.position_after.position
        else:
            self.min_position = min(self.position_before.position, self.position_after.position-1)
            self.max_position = max(self.position_before.position+1, self.position_after.position)
        self.full_position = str(self)
        # split chromosome into name and number (if it has a number), to make chromosome 16 sort after 5 instead of before
        chromosome_data = re.search('^(.*[^\d]?)(\d*)', self.chromosome)
        self.chromosome_name = chromosome_data.group(1)
        self.chromosome_number = int(chromosome_data.group(2)) if chromosome_data.group(2) else 0
        self.all_position_values = (self.chromosome_name, self.chromosome_number, 
                                    self.min_position, self.max_position, self.strand)

    # LATER-TODO add some kind of merge function to merge two positions into one!  For when I'm merging two position-based groups together because they're actually probably the same mutant with some sequencing errors.

    def __cmp__(self,other):
        return cmp(self.all_position_values, other.all_position_values)

    def __str__(self): 
        divider = '-'
        info_before = str(self.position_before) if self.position_before is not None else '?'
        info_after = str(self.position_after) if self.position_after is not None else '?'
        return info_before+divider+info_after

    # LATER-TODO add unit tests for this whole class!


def get_insertion_pos_from_HTSeq_read_position(HTSeq_pos, cassette_end, read_is_reverse=False):
    """ Return a Insertion_position instance giving the cassette insertion position based on HTSeq read position. 

    HTSeq_pos should be a HTSeq.GenomicPosition instance; cassette_end gives the side of the insertion that read is on; 
     read_is_reverse is True if the read is in reverse orientation to the cassette. 

    The cassette chromosome will be the same as read chromosome; the cassette strand will be the same as read strand, 
     or opposite if read_is_reverse is True.

    The cassette position depends on read position, cassette strand (not read strand) and cassette_end in a complex way:
     Data I have:  which end of the insertion cassette the read is on, and which orientation the cassette is in. 
     Data I want:  the position of the base before and after the insertion, regardless of cassette orientation.
                       (the read orientation in regard to cassette doesn't matter at all here)
     If read is 5' of cassette and cassette is +, or read is 3' of cassette and cassette is -, read is BEFORE cassette
     If read is 3' of cassette and cassette is +, or read is 5' of cassette and cassette is -, read is AFTER cassette
      If read is before cassette, I care about the end of the read; if it's after, I care about the start)
      SAM alignment position is leftmost/rightmost, i.e. end is always the "later" position in the genome, 
       regardless of the read orientation, which gives me what I want, i.e. the insertion position.

    Insertion_position uses a 1-based position system (as opposed to HTSeq, which is 0-based).
    """
    ### chromosome is always the same as read (also checking that the HTSeq_pos has a chrom attribute at all here)
    try:
        chrom = HTSeq_pos.chrom
    except AttributeError:
        raise ValueError("Invalid position %s! Need an HTSeq iv object. (If empty, maybe read wasn't aligned?)"%HTSeq_pos)
    ### cassette strand is the same as read strand, OR the opposite if read_is_reverse is True
    strand = HTSeq_pos.strand
    if read_is_reverse:     strand = '+' if strand=='-' else '-'
    ### cassette position depends on the read position and cassette_end in a somewhat complex way 
    #   (see description in docstring, and ../notes.txt for even more detail)
    # HTSeq is 0-based and I want 1-based, thus the +1; end has no +1 because in HTSeq end is the base AFTER the alignment.
    if (cassette_end=='5prime' and strand=='+') or (cassette_end=='3prime' and strand=='-'):      
        pos_before, pos_after = HTSeq_pos.end, None
    elif (cassette_end=='3prime' and strand=='+') or (cassette_end=='5prime' and strand=='-'):    
        pos_before, pos_after = None, HTSeq_pos.start+1
    else:                           
        raise ValueError("cassette_end argument must be one of %s."%SEQ_ENDS)
    return Insertion_position(chrom, strand, pos_before, pos_after)


### Main classes describing the reads groups and datasets

class Insertional_mutant_data():
    """ Data regarding sequences aligned to a particular genomic position (genomic position is set at initialization). 
    Variables: chromosome, position, total_read_count, perfect_read_count, unique_sequence_count, 
      sequences_and_counts (a sequence:count dictionary).
    Methods: add_read to add a given HTSeq read to the counts (doesn't check chromosome/position), 
     get_main_sequence to get the most common sequence from sequences_and_counts. """

    def __init__(self, insertion_position):
        """ Set self.position based on argument ; initialize read/sequence counts to 0 and gene-info to unknown. 
        insertion_position argument should be a Insertion_position instance. """
        self.position = insertion_position
        self.gene = SPECIAL_GENE_CODES.not_determined
        self.orientation = '?'
        self.gene_feature = '?'
        self.total_read_count = 0
        self.perfect_read_count = 0
        self.unique_sequence_count = 0
        self.sequences_and_counts = defaultdict(lambda: 0)

    # MAYBE-TODO give each mutant some kind of unique ID at some point in the process?  Or is genomic location sufficient?  If we end up using per-mutant barcodes (in addition to the flanking sequences), we could use that, probably, or that plus genomic location.

    def add_read(self, HTSeq_alignment, read_count=1, treat_unknown_as_match=False):
        """ Add a read to the data (or multiple identical reads, if read_count>1); return True if perfect match.
        Specifically: increment total_read_count, increment perfect_read_count if read is a perfect 
        alignment, increment the appropriate field of sequences_and_counts based on read sequence.
        Note: this does NOT check the read position to make sure it matches that of the object."""
        # MAYBE-TODO check HTSeq_alignment chromosome/strand to make sure it matches data in self?  Don't check position, that's more complicated (it can be either start or end) - could maybe check that position is within, idk, 10bp of either alignment start or alignment end?  Or not - I may want to cluster things in a non-position-based way anyway!  Hmmm...
        seq = HTSeq_alignment.read.seq
        # if it's a new sequence, increment unique_sequence_count; add a count to the self.sequences_and_counts dictionary.
        if seq not in self.sequences_and_counts:
            self.unique_sequence_count += 1
        self.sequences_and_counts[seq] += read_count
        # increment self.total_read_count; figure out if the read is perfect and increment self.perfect_read_count if yes.
        self.total_read_count += read_count
        treat_unknown_as = 'match' if treat_unknown_as_match else 'mutation'
        mutation_count = check_mutation_count_try_all_methods(HTSeq_alignment, treat_unknown_as=treat_unknown_as)
        if mutation_count==0:  
            self.perfect_read_count += read_count
            return True
        else:
            return False

    # LATER-TODO write a function to merge two instances together!  Merge their position (or just pick one position), add read counts together (should perfect reads from the wrong position still count as perfect though?), merge their sequences (may want to keep more data about sequences! Like exact position and number of mutations) (may want to store a list of HTSeq.alignment objects instead of just sequences+counts, really)

    def add_counts(self, total_count, perfect_count, sequence_variant_count, assume_new_sequences=False):
        """ Increment self.total_read_count, self.perfect_read_count and self.unique_sequence_count based on inputs.
        Note that ifself.unique_sequence_count>0, it's impossible to determine the correct new value: 
         if we had old data with one unique sequence and now we have new data with another one, how do we know
          if that's the same or different sequence?  The correct total could be 1 or 2, so it's an option:
         If assume_new_sequences is True, the total is old+new; if it's False, the total is max(old,new).
        """
        self.total_read_count += total_count
        self.perfect_read_count += perfect_count
        if assume_new_sequences:
            self.unique_sequence_count += sequence_variant_count
        else:
            self.unique_sequence_count = max(self.unique_sequence_count,sequence_variant_count)

    def add_sequence_and_counts(self, seq, seq_count, add_to_uniqseqcount=True):
        """ Add seq_count to self.sequences_and_counts[seq] (it's created with count 0 if seq wasn't a key before).
        Note: if add_to_uniqseqcount is False, this will never increment self.unique_sequence_count;
         otherwise it only does so if seq was not already present in the self.sequences_and_counts data
          and if the total number of sequences in self.sequences_and_counts is higher than self.unique_sequence_count. """
        if add_to_uniqseqcount:
            if seq not in self.sequences_and_counts and len(self.sequences_and_counts)>self.unique_sequence_count:
                self.unique_sequence_count += 1
        self.sequences_and_counts[seq] += seq_count

    def get_main_sequence(self, N=1):
        """ Return the most common sequence in this group and its count (or Nth most common sequence if N is provided)."""
        sequences_by_count = sorted([(count,seq) for (seq,count) in self.sequences_and_counts.iteritems()], reverse=True)
        # try returning the Nth sequence and count; return nothing if there are under N sequences.
        try:                return (sequences_by_count[N-1][1], sequences_by_count[N-1][0])
        except IndexError:  return ('',0)


class Insertional_mutant_library_dataset():
    """ Essentially a dictionary of Insertional_mutant_data with position data (chrom,strand,pos) as keys. """

    def __init__(self, cassette_end=None, read_is_reverse=False):
        """ Checks cassette_end and assigns to self.cassette_end; initializes self.data_by_position.
        cassette_end must be one of %s.
        self.data_by_position is a dictionary that generates a new Insertional_mutant_data object
         based on the key (i.e. position) if the key isn't already in the dictionary.  """%SEQ_ENDS
         # make sure the arguments are valid values
        if not cassette_end in SEQ_ENDS+[None]: 
            raise ValueError("The cassette_end variable must be one of %s!"%SEQ_ENDS)
        self.cassette_end = cassette_end
        if not read_is_reverse in [True,False]: 
            raise ValueError("The read_is_reverse variable must be True or False!")
        self.read_is_reverse = read_is_reverse
        # MAYBE-TODO should read_is_reverse be specified for the whole dataset, or just for each set of data added? Might be better to make it an option to add_alignment_reader_to_data and just switch the orientation of reads as they're added to the data, to make it possible to add both forward and reverse read sets to one Insertional_mutant_library_dataset dataset. - but then I'd have to keep track of (and print in outfile?) cassette_end and read_is_reverse for every read instead of just keeping it once per dataset - complicated.
        # data_by_position is the main data structure here
        self.data_by_position = {}
        # various total read/group counts to keep track of
        self.discarded_read_count = 'unknown'
        self.total_read_count, self.aligned_read_count, self.unaligned_read_count, self.perfect_read_count = 0,0,0,0
        self.ignored_region_read_counts = defaultdict(lambda: 0)
        self.strand_read_counts = defaultdict(lambda: 0)
        self.specific_region_read_counts = defaultdict(lambda: 0)
        self.read_groups_in_genes, self.read_groups_not_in_genes, self.read_groups_undetermined = 0,0,0
        self.read_groups_sense, self.read_groups_antisense = 0,0
    
    def add_discarded_reads(self, N, reset_count=False):
        """ Add N to self.discarded_read_count (or set self.discarded_read_count to N if reset_count is True). """
        if reset_count or self.discarded_read_count=='unknown':
            self.discarded_read_count = int(N)
        else:
            self.discarded_read_count += int(N)

    def add_alignment_reader_to_data(self, HTSeq_alignment_reader, uncollapse_read_counts=False, 
                                     treat_unknown_as_match=False, chromosomes_to_count=[], chromosomes_to_ignore=[]):
        """ Adds all alignments to self.data_by_position based on position.

        Input must be a list/generator/etc of HTSeq.Alignment objects (usually an HTSeq.SAM_Reader).
        Set uncollapse_read_counts to True if the original deepseq data was collapsed to unique sequences using
         fastx_uncollapser before alignment, to get the correct original read counts.
        Treat_unknown_as_match governs whether alignments with no detailed information are treated as perfect or not.
        Chromosomes_to_count is a list of chromosomes that should have aligned read counts kept 
         and added to the header summary (they're treated normally otherwise). 
        Reads that align to a chromosome in the chromosomes_to_ignore list will be ignored in the data 
         (but not the total counts contained in the header). 
        """

        if self.cassette_end is None:
            raise Exception("Cannot add data from an alignment reader if cassette_end isn't specified! Please set the cassette_end attribute of this Insertional_mutant_library_dataset instance to one of %s first."%SEQ_ENDS)
        for aln in HTSeq_alignment_reader:
            if uncollapse_read_counts:      read_count = get_seq_count_from_collapsed_header(aln.read.name)
            else:                           read_count = 1
            self.total_read_count += read_count
            # if read is unaligned, add to unaligned count and skip to the next read
            if (not aln.aligned) or (aln.iv is None):
                self.unaligned_read_count += read_count
                continue
            # get the cassette insertion position (as an Insertion_position object)
            insertion_pos = get_insertion_pos_from_HTSeq_read_position(aln.iv, self.cassette_end, self.read_is_reverse)
            chrom = insertion_pos.chromosome
            strand = insertion_pos.strand
            pos = insertion_pos.min_position
            # if read is aligned to one of the chromosomes_to_ignore, add to the right count and skip to the next read
            if chrom in chromosomes_to_ignore:
                self.ignored_region_read_counts[chrom] += read_count
                continue
            # if read is aligned to anything else, add to aligned count, strand counts etc
            self.aligned_read_count += read_count
            self.strand_read_counts[strand] += read_count
            # MAYBE-TODO do I want info on how many reads were aligned to which strand for the chromosomes_to_count or even all chromosomes?  Maybe optionally...  And how many were perfect, and how many groups there were... Might want to write a separate class or function just for this.  If so, should output it in a tabular format, with all the different data (reads, +, -, perfect, ...) printed tab-separated in one row.
            if chrom in chromosomes_to_count:
                self.specific_region_read_counts[chrom] += read_count
            # check if there's already a read group at that position; if not, make a new one
            if (chrom,strand,pos) not in self.data_by_position.keys():
                # LATER-TODO may want to check whether the read should be added to another group before making a new one - 
                #   for example if it's 1bp away from an existing one?  Or just do all those group-merge checks at the end.
                self.data_by_position[(chrom,strand,pos)] = Insertional_mutant_data(insertion_pos)
            # add_read adds the read to the full data; also returns True if alignment was perfect, to add to perfect_count
            if self.data_by_position[(chrom,strand,pos)].add_read(aln, read_count, treat_unknown_as_match):
                self.perfect_read_count += read_count
        # LATER-TODO at this point, may want to go over the full list of groups and see if any of them should be merged (for example because they're only 1bp apart and one of them has only one read and the other has thousands), or have issues (like are too close together, or have more imperfect than perfect reads, or something) - or maybe that should be a separate function?

    def add_gene_positions_to_data(self, genefile, detailed_features=False, gene_info_file=None, 
                                   liberal_position_test=False, known_bad_chromosomes=[]):
        """ Look up gene positions for each read group using genefile and add to data; 
        if detailed_features is True, also look up whether the group is in an exon/intron/UTR (NOT IMPLEMENTED); 
        if gene_info_file is not None, use it to get gene names/descriptions/other info as well (NOT IMPLEMENTED).
        If liberal_position_test is False, the insertion position must definitely be inside the gene; 
         if True, it's sufficient that is may be inside or bordering the gene (depending on ambiguity).
        """ 
        # parse the genefile reference using BCBio.GFF - first ONLY look at "gene" features
        reference_by_chromosome = parse_gene_pos_file(genefile)
        # how to tell whether pos is inside gene - pick a (liberal or strict) function from DNA_basic_utilities
        if liberal_position_test:   position_test_function = position_test_overlap
        else:                       position_test_function = position_test_contains
        # go over all read groups, and figure out which gene they're in (if any), keep track of totals
        for read_group in self.data_by_position.itervalues():
            gene_ID, orientation = find_gene_by_pos(read_group.position, reference_by_chromosome, 
                                                    position_test_function, known_bad_chromosomes)
            read_group.gene = gene_ID
            read_group.orientation = orientation
            # TODO in addition to gene ID and orientation, we want detailed feature location (exon/intron/UTR) (OPTIONAL)
            # LATER-TODO we also want gene name/description/stuff from gene_info_file, if given! Currently not implemented.  Should probably only use gene name in the line-per-mutant output, and only add other gene info (description etc) to the line-per-gene output.
            if gene_ID==SPECIAL_GENE_CODES.chromosome_not_in_reference:     self.read_groups_undetermined += 1
            elif gene_ID==SPECIAL_GENE_CODES.not_found:                     self.read_groups_not_in_genes += 1
            else:                                                           self.read_groups_in_genes += 1
            if orientation=='sense':                self.read_groups_sense += 1
            elif orientation=='antisense':          self.read_groups_antisense += 1
        # LATER-TODO add a run-test case for this!

    def find_most_common_group(self):
        """ Return the Insertional_mutant_data object from self.data_by_position with the most total reads."""
        current_readcount = 0
        current_group = None
        for read_group in self.data_by_position.itervalues():
            if read_group.total_read_count > current_readcount:
                current_readcount = read_group.total_read_count
                current_group = read_group
        return current_group

    def print_summary(self, OUTPUT=sys.stdout, line_prefix='    ', header_prefix=' * '):
        """ Print basic read and group counts (prints to stdout by default, can also pass an open file object)."""
        OUTPUT.write(line_prefix+"Reads discarded in preprocessing: %s\n"%(self.discarded_read_count))
        OUTPUT.write(header_prefix+"Total reads processed: %s\n"%(self.total_read_count))
        OUTPUT.write(line_prefix+"Unaligned reads: %s\n"%(self.unaligned_read_count))
        for (region,count) in self.ignored_region_read_counts.iteritems():
            OUTPUT.write(line_prefix+"Discarded reads aligned to %s: %s\n"%(region, count))
        OUTPUT.write(line_prefix+"Aligned reads (non-discarded): %s\n"%(self.aligned_read_count))
        OUTPUT.write(line_prefix+"Perfectly aligned reads (no mismatches): %s\n"%(self.perfect_read_count))
        for (strand,count) in self.strand_read_counts.iteritems():
            OUTPUT.write(line_prefix+"Reads with insertion direction matching chromosome %s strand: %s\n"%(strand, count))
        for (region,count) in self.specific_region_read_counts.iteritems():
            OUTPUT.write(line_prefix+"Reads aligned to %s: %s\n"%(region, count))
        # MAYBE-TODO add percentages of total (or aligned) reads to all of these numbers in addition to raw counts!
        # MAYBE-TODO keep track of the count of separate groups (mutants) in each category, as well as total read counts?
        OUTPUT.write(header_prefix+"Read groups by cassette insertion position (distinct mutants): %s\n"%\
                                                                                     (len(self.data_by_position)))
        OUTPUT.write(line_prefix+"(read is at %s end of cassette, in %s direction to cassette)\n"%(self.cassette_end, 
                                                                    ('reverse' if self.read_is_reverse else 'forward')))
        g = self.find_most_common_group()
        OUTPUT.write(line_prefix+"Most common group: %s, position %s, %s strand:"%(g.position.chromosome,
                                                                           g.position.full_position, g.position.strand))
        OUTPUT.write(" %s reads (%.0f%% of aligned)\n"%(g.total_read_count, 
                                                        100.0*g.total_read_count/self.aligned_read_count))
        # MAYBE-TODO may also be a good idea to keep track of the most common SEQUENCE, not just group...
        # print the gene annotation info, but only if there is any
        if self.read_groups_in_genes + self.read_groups_not_in_genes + self.read_groups_undetermined:
            OUTPUT.write(line_prefix+"Read groups inside genes: %s\n"%(self.read_groups_in_genes))
            OUTPUT.write(line_prefix+"Read groups not inside genes: %s\n"%(self.read_groups_not_in_genes))
            OUTPUT.write(line_prefix+"Read groups in unknown chromosomes: %s\n"%(self.read_groups_undetermined))
            OUTPUT.write(line_prefix+"Read groups in sense orientation to gene: %s\n"%(self.read_groups_sense))
            OUTPUT.write(line_prefix+"Read groups in antisense orientation to gene: %s\n"%(self.read_groups_antisense))
            all_genes = set([group.gene for group in self.data_by_position.values()]) - set(SPECIAL_GENE_CODES.all_codes)
            OUTPUT.write(line_prefix+"Genes containing at least one read group: %s\n"%(len(all_genes)))
            # LATER-TODO Add count of genes containing at least two groups! Once I have a per-gene view of the data.

    def print_data(self, OUTPUT=None, sort_data=False, N_sequences=2, header_line=True, header_prefix="# "):
        """ Print the full data:  the read count for each group of sequences with the same position.
        If N_sequences<1, only prints position (chromosome and position), total and perfect read count, 
          and the number of sequence variants.  If N_sequences==1, also prints the most common sequence and count; 
          if N_sequences>1, adds the second most common sequence and count, and so on.
        Output is tab-separated, with headers starting with "# ".  Prints to an open file object (stdout by default).
        """
        # MAYBE-TODO should printing the gene info be optional?  Maybe... Would save space when there isn't any meaningful gene info to print anyway.
        if OUTPUT is None:
            OUTPUT = sys.stdout

        if header_line:
            headers = ['chromosome','strand','min_position','full_position',
                       'gene','orientation','feature',
                       'total_reads','perfect_reads', 'N_sequence_variants']
            for N in range(1,N_sequences+1):
                headers.extend(['read_sequence_%s'%N,'seq_%s_count'%N])
            OUTPUT.write(header_prefix + '\t'.join(headers) + "\n")

        if sort_data:
            data = sorted(self.data_by_position.values(), key = lambda x: x.position)
            # x.position here is an Insertion_position object and has a sensible cmp function
        else:
            data = self.data_by_position.itervalues()

        for group in data:
            group_data = [group.position.chromosome, group.position.strand, group.position.min_position, group.position, 
                          group.gene, group.orientation, group.gene_feature, 
                          group.total_read_count, group.perfect_read_count, group.unique_sequence_count]
            OUTPUT.write('\t'.join([str(x) for x in group_data]))
            for N in range(1,N_sequences+1):
                OUTPUT.write('\t%s\t%s'%group.get_main_sequence(N))
                # MAYBE-TODO also give the length and number of mutations for each sequence? Optionally?  Length is easy, but do I even keep track of mutation number?  I probably should...
            OUTPUT.write('\n')

    def read_from_file(self, infile, assume_new_sequences=False):
        """ Read data from a file generated by self.print_data, and add to self.data_by_position.  
        Note that if you read data from a file and add it to data that already exists, it's impossible to determine the 
         correct number of unique sequence variants per group: if the data originally listed 1 unique sequence, and new
          data read from a file adds another 2 sequences, is that a total of 2 or 3 unique sequences? 
         If assume_new_sequences is True, the total is old+new; if it's False, the total is max(old,new).
        Currently doesn't read the specific sequences and counts - even if it did, some information could 
        always be missing, since the file only has N first sequences. """
        # NOTE: this function is half-finished, really (basic functionality fine but things missing, see MAYBE-TODOs), and I'm not sure it's actually going to be necessary after some more rewrites, or in what form, so I'm leaving it as is for the moment.  It has a unit-test but I turned it off (by renaming it from test_ to notest_) because right now I don't care that it fails.
        for line in open(infile):
            # LATER-TODO get unaligned/discarded/etc read count from summary, so we can keep track of full counts!
            # ignore comment and header lines
            if line.startswith('#'):    continue
            if line.startswith('chromosome\tstrand\tposition\t'):    continue
            fields = line.split('\t')
            chromosome = fields[0]
            strand = fields[1]
            pos = int(fields[2])
            gene = fields[3]
            orientation = fields[4]
            gene_feature = fields[5]
            total_reads,perfect_reads,sequence_variants = [int(x) for x in fields[6:9]]
            self.data_by_position[(chromosome,strand,pos)].add_counts(total_reads, perfect_reads, 
                                                                           sequence_variants, assume_new_sequences)
            self.data_by_position[(chromosome,strand,pos)].gene = gene
            self.data_by_position[(chromosome,strand,pos)].orientation = orientation
            self.data_by_position[(chromosome,strand,pos)].gene_feature = gene_feature
            # MAYBE-TODO split the remaining fields into twos (seq,count) (we don't know how many there will be) 
            #   and use self.data_by_position[(chromosome, position)].add_sequence_and_counts(seq,count) 
            #   to add specific sequences and counts to the data.  Add to unit-test!
        self.aligned_read_count = sum([x.total_read_count for x in self.data_by_position.values()])
        self.total_read_count = self.aligned_read_count + self.unaligned_read_count
    
# MAYBE-TODO I think later I'll want another way of organizing Insertional_mutant_data objects - by gene, or by chromosome instead of chromosome+position, or such... don't get too stuck on Insertional_mutant_library_dataset!  Or I could just add other mutant-organization dictionaries/views to the same class, that might be better really...

# LATER-TODO at some point I'll probably want to generalize both of those classes to not necessarily be grouped by position...
# LATER-TODO Hmmm, do I REALLY need my main data type to be a dictionary by position, or could it just be a set? Do I ever look anything up in this dictionary??  Oh, yeah, I do, when adding new reads that were aligned to the same position as some other reads.  But if I did clustering earlier, that would stop being an issue... And if I want to take adjacent groups and merge them together, the position-based key will stop being very meaningful anyway... Hmmmm. May need a more complicated method. For now, could have the dict key be precise alignment chrom/pos/strand, but have a full position object in the read group object. 
# Okay, so how SHOULD I do the clustering?  Two basic options here: either cluster all the reads FIRST and THEN organize them into Insertional_mutant_data objects, or just keep a set of Insertional_mutant_data objects and whenever a new read is added, run a function on the new read and the existing set to find which one to add it to.  THIS IS COMPLICATED, I DON'T KNOW IF I SHOULD BE DOING IT RIGHT NOW... Try to implement something very simple that I can expand later?



######### Test code #########

class Testing_single_functions(unittest.TestCase):
    """ Unit-tests for most of the top-level functions in this module. """

    class Fake_pos:
        def __init__(self, chrom, strand, start, end):
            self.chrom = chrom
            self.strand = strand
            self.start = start
            self.end = end

    def test__make_joint_position(self):
        assert make_joint_position(None) == None
        for arg in ['', [], {}, 'aaa', True, False]:
            self.assertRaises(ValueError, make_joint_position, arg)
        assert make_joint_position(100) == SeqFeature.ExactPosition(100)
        assert make_joint_position([100,100]) == SeqFeature.ExactPosition(100)
        assert make_joint_position([100,103]) == SeqFeature.WithinPosition(100,3)
        assert make_joint_position([100,103,102,102,101]) == SeqFeature.WithinPosition(100,3)

    def test__get_insertion_pos_from_HTSeq_position(self):
        # should raise exception for invalid HTSeq_pos argument
        for bad_HTSeq_pos in [None, '', 'aaa', 0, 1, 0.65, [], {}, True, False]:
            for cassette_end in SEQ_ENDS:
                self.assertRaises(ValueError, get_insertion_pos_from_HTSeq_read_position, None, cassette_end)
        # should raise exception for invalid cassette_end
        fake_pos = self.Fake_pos('C', '+', 0, 5)
        for bad_cassette_end in ['','aaa',0,1,[],{},None,True,False,'start','end','middle','read','leftmost','rightmost']:
            self.assertRaises(ValueError, get_insertion_pos_from_HTSeq_read_position, fake_pos, bad_cassette_end)
        ### testing normal functionality: should return an Insertion_position instance with the same chromosome, 
        #    and strand/position depending on the arguments in a somewhat complicated way.
        ## a few spot-checks outside the loop 
        #   (based on the example at the end of "Possible read sides/directions" section in ../notes.txt)
        # remember HTSeq position is 0-based and end-exclusive, and the position I want is 1-based end-inclusive!  
        #  So in the end the two relevant 1-based numbers end up being the same as the 0-based positions,
        #  because in the case of the start, min_position is actually start-1, and in the case of the end, we're adding 1
        #  to switch from 0-based to 1-based but then subtracting 1 to make the end the last base instead of the base after
        fake_pos_plus = self.Fake_pos('C', '+', 3, 7)
        fake_pos_minus = self.Fake_pos('C', '-', 3, 7)
        assert get_insertion_pos_from_HTSeq_read_position(fake_pos_plus, '5prime',read_is_reverse=False).min_position == 7
        assert get_insertion_pos_from_HTSeq_read_position(fake_pos_plus, '3prime',read_is_reverse=False).min_position == 3
        assert get_insertion_pos_from_HTSeq_read_position(fake_pos_minus,'5prime',read_is_reverse=True).min_position == 7
        assert get_insertion_pos_from_HTSeq_read_position(fake_pos_minus,'3prime',read_is_reverse=True).min_position == 3
        assert get_insertion_pos_from_HTSeq_read_position(fake_pos_plus, '5prime',read_is_reverse=True).min_position == 3
        assert get_insertion_pos_from_HTSeq_read_position(fake_pos_plus, '3prime',read_is_reverse=True).min_position == 7
        assert get_insertion_pos_from_HTSeq_read_position(fake_pos_minus,'5prime',read_is_reverse=False).min_position == 3
        assert get_insertion_pos_from_HTSeq_read_position(fake_pos_minus,'3prime',read_is_reverse=False).min_position == 7
        # more checks in a loop - see above for what we expect!
        for (strand_in, if_reverse, strand_out) in [('+',False,'+'), ('-',False,'-'), ('+',True,'-'), ('-',True,'+')]:
            for (start,end) in [(0,5), (0,100), (10,11), (5,44)]:
                fake_pos = self.Fake_pos('C', strand_in, start, end)
                result_5prime = get_insertion_pos_from_HTSeq_read_position(fake_pos, '5prime', if_reverse)
                result_3prime = get_insertion_pos_from_HTSeq_read_position(fake_pos, '3prime', if_reverse)
                assert result_5prime.chromosome == result_3prime.chromosome == 'C'
                assert result_5prime.strand == result_3prime.strand == strand_out
                if strand_out=='+':
                    assert result_5prime.min_position == end
                    assert result_3prime.min_position == start
                elif strand_out=='-':
                    assert result_5prime.min_position == start
                    assert result_3prime.min_position == end


class Testing_Alignment_position_sequence_group(unittest.TestCase):
    """ Unit-tests for the Insertional_mutant_data class and its methods. """

    def test__init(self):
        for chromosome in ['chr1', 'chromosome_2', 'chrom3', 'a', 'adfads', '100', 'scaffold_88']:
            for strand in ['+','-']:
                for position in [1,2,5,100,10000,4323423]:
                    ins_pos_5prime = Insertion_position(chromosome,strand,position_before=position)
                    ins_pos_3prime = Insertion_position(chromosome,strand,position_after=position)
                    group_5prime = Insertional_mutant_data(ins_pos_5prime)
                    group_3prime = Insertional_mutant_data(ins_pos_3prime)
                    assert group_5prime.position.min_position == position
                    assert group_3prime.position.min_position == position-1
                    assert group_5prime.position.max_position == position+1
                    assert group_3prime.position.max_position == position
                    assert group_5prime.position.full_position == "%s-?"%(position)
                    assert group_3prime.position.full_position == "?-%s"%position
                    for group in [group_5prime,group_3prime]:
                        assert group.position.chromosome == chromosome
                        assert group.position.strand == strand
                        assert group.gene == SPECIAL_GENE_CODES.not_determined
                        assert group.orientation == '?'
                        assert group.gene_feature == '?'
                        assert group.total_read_count == 0
                        assert group.perfect_read_count == 0
                        assert group.unique_sequence_count == 0
                        assert group.sequences_and_counts == {}

    def test__add_read(self):
        pass
        # MAYBE-TODO implement using a mock-up of HTSeq_alignment?  (see Testing_single_functions for how I did that)

    def test__add_counts(self):
        group = Insertional_mutant_data(Insertion_position('chr','+',3))
        group.add_counts(0,0,0)
        assert group.total_read_count == 0
        assert group.perfect_read_count == 0
        assert group.sequences_and_counts == {}
        group.add_counts(2,2,1)
        assert group.total_read_count == 2
        assert group.perfect_read_count == 2
        assert group.sequences_and_counts == {}
        group.add_counts(2,1,1)
        assert group.total_read_count == 4
        assert group.perfect_read_count == 3
        assert group.sequences_and_counts == {}
        # how group.unique_sequence_count changes depends on assume_new_sequences:
        #  - if False, group.unique_sequence_count is max(new_seq_count, group.unique_sequence_count)
        group = Insertional_mutant_data(Insertion_position('chr','+',3))
        group.add_counts(0,0,0,assume_new_sequences=False)
        assert group.unique_sequence_count == 0
        group.add_counts(1,1,1,assume_new_sequences=False)
        assert group.unique_sequence_count == 1
        group.add_counts(2,2,2,assume_new_sequences=False)
        assert group.unique_sequence_count == 2
        group.add_counts(1,1,1,assume_new_sequences=False)
        assert group.unique_sequence_count == 2
        group.add_counts(2,2,2,assume_new_sequences=False)
        assert group.unique_sequence_count == 2
        #  - if True and group.unique_sequence_count is new_seq_count + group.unique_sequence_count
        group = Insertional_mutant_data(Insertion_position('chr','+',3))
        group.add_counts(0,0,0,assume_new_sequences=True)
        assert group.unique_sequence_count == 0
        group.add_counts(1,1,1,assume_new_sequences=True)
        assert group.unique_sequence_count == 1
        group.add_counts(2,2,2,assume_new_sequences=True)
        assert group.unique_sequence_count == 3
        group.add_counts(1,1,1,assume_new_sequences=True)
        assert group.unique_sequence_count == 4
        group.add_counts(2,2,2,assume_new_sequences=True)
        assert group.unique_sequence_count == 6
        group.add_counts(2,2,2,assume_new_sequences=False)
        assert group.unique_sequence_count == 6

    def test__add_sequence_and_counts(self):
        group = Insertional_mutant_data(Insertion_position('chr','+',3))
        # adding sequence/count to group.sequences_and_counts, WITHOUT touching group.unique_sequence_count
        group.add_sequence_and_counts('AAA',2,add_to_uniqseqcount=False)
        assert group.sequences_and_counts == {'AAA':2}
        assert group.unique_sequence_count == 0
        # adding sequence/count to group.sequences_and_counts, and incrementing group.unique_sequence_count if warranted:
        #  - if adding a sequence that was already there, don't increment
        group.add_sequence_and_counts('AAA',2,add_to_uniqseqcount=True)
        assert group.sequences_and_counts == {'AAA':4}
        assert group.unique_sequence_count == 0
        #  - if adding a new sequence, increment
        group.add_sequence_and_counts('GGG',2,add_to_uniqseqcount=True)
        assert group.sequences_and_counts == {'AAA':4, 'GGG':2}
        assert group.unique_sequence_count == 1
        #  - if adding a new sequence but group.unique_sequence_count is already higher than expected, don't increment
        group.unique_sequence_count = 5
        group.add_sequence_and_counts('CCC',2,add_to_uniqseqcount=True)
        assert group.sequences_and_counts == {'AAA':4, 'GGG':2, 'CCC':2}
        assert group.unique_sequence_count == 5
        # make sure it raises an error if given a non-numeric argument
        for not_a_number in [None,'','a','GGG']:
            self.assertRaises(TypeError,group.add_sequence_and_counts,'CCC',not_a_number)

    def test__get_main_sequence(self):
        group = Insertional_mutant_data(Insertion_position('chr','+',3))
        assert group.get_main_sequence() == ('',0)
        assert group.get_main_sequence(1) == ('',0)
        assert group.get_main_sequence(4) == ('',0)
        group.add_sequence_and_counts('AAA',1)
        group.add_sequence_and_counts('GGG',2)
        assert group.sequences_and_counts == {'AAA':1, 'GGG':2}
        assert group.get_main_sequence() == ('GGG',2)
        assert group.get_main_sequence(1) == ('GGG',2)
        assert group.get_main_sequence(2) == ('AAA',1)
        assert group.get_main_sequence(3) == ('',0)
        assert group.get_main_sequence(4) == ('',0)
        group.add_sequence_and_counts('CCC',1)
        group.add_sequence_and_counts('AAA',2)
        assert group.sequences_and_counts == {'AAA':3, 'GGG':2, 'CCC':1}
        assert group.get_main_sequence() == ('AAA',3)
        assert group.get_main_sequence(1) == ('AAA',3)
        assert group.get_main_sequence(2) == ('GGG',2)
        assert group.get_main_sequence(3) == ('CCC',1)
        assert group.get_main_sequence(4) == ('',0)
        assert group.get_main_sequence(5) == ('',0)


class Testing_All_alignments_grouped_by_pos(unittest.TestCase):
    """ Unit-tests for the Insertional_mutant_library_dataset class and its methods. """

    def test__init(self):
        for cassette_end in SEQ_ENDS+[None]:
            data = Insertional_mutant_library_dataset(cassette_end)
            assert data.cassette_end == cassette_end
            assert data.data_by_position == {}
            assert data.total_read_count == 0
            assert data.aligned_read_count == 0
            assert data.unaligned_read_count == 0
        for cassette_end in [True, False, 0, 0.11, 23, 'asdfas', '', 'something', [2,1]]:
            self.assertRaises(ValueError, Insertional_mutant_library_dataset, cassette_end)
        # LATER-TODO rewrite this to add new args/features

    # LATER-TODO add unit-test for add_discarded_reads, add_gene_positions_to_data, find_most_common_group, 

    def test__add_alignment_reader_to_data(self):
        pass
        # MAYBE-TODO implement using a mock-up of HTSeq_alignment?  (see Testing_single_functions for how I did that)
        #   make sure it fails if self.cassette_end isn't defined...

    def test__print_summary(self):
        pass
        # MAYBE-TODO implement based on stuff in test_data, like do_test_run in deepseq_count_alignments.py?

    def test__print_data(self):
        pass
        # MAYBE-TODO implement based on stuff in test_data, like do_test_run in deepseq_count_alignments.py?

    def no_test__read_from_file(self):
        input_file = 'test_data/test_output__leftmost.txt'
        data = Insertional_mutant_library_dataset(None)
        data.read_from_file(input_file)
        assert data.aligned_read_count == 30
        assert data.unaligned_read_count == 0
        assert data.total_read_count == 30
        # just spot-checking some of the outputs
        group = data.data_by_position[('reads_2_seqs_1','+',199)]
        assert group.chromosome == 'reads_2_seqs_1'
        assert group.position == 199
        assert group.total_read_count == 2
        assert group.perfect_read_count == 2 
        assert group.unique_sequence_count == 1
        group = data.data_by_position[('mutation_yes','+',199)]
        assert group.chromosome == 'mutation_yes'
        assert group.position == 199
        assert group.total_read_count == 6
        assert group.perfect_read_count == 0
        assert group.unique_sequence_count == 1
        group = data.data_by_position[('strandedness_+_reference','+',99)]
        assert group.chromosome == 'strandedness_+_reference'
        assert group.position == 99
        assert group.total_read_count == 1
        assert group.perfect_read_count == 1
        assert group.unique_sequence_count == 1
        # try adding more data to a file that already has some...
        data.read_from_file(input_file, assume_new_sequences=False)
        group = data.data_by_position[('reads_2_seqs_1','+',199)]
        assert group.chromosome == 'reads_2_seqs_1'
        assert group.position == 199
        assert group.total_read_count == 4
        assert group.perfect_read_count == 4
        # how group.unique_sequence_count should act in this case depends on the value of assume_new_sequences
        assert group.unique_sequence_count == 1
        data.read_from_file(input_file, assume_new_sequences=True)
        assert group.unique_sequence_count == 2


if __name__ == "__main__":
    """ Allows both running and importing of this file. """
    print("*** This is a module to be imported to other files - running the built-in test suite. ***")
    unittest.main(argv=[sys.argv[0]])
    # if I wanted more control I could do this instead:
    #import os
    #unittest.TextTestRunner(verbosity=1).run(unittest.defaultTestLoader.loadTestsFromName(os.path.splitext(sys.argv[0])[0]))
    #   (autodetection of all tests - see http://docs.python.org/library/unittest.html#unittest.TestLoader)
    # there's probably also some way to easily get all tests from the current file without passing the name, but I haven't found it yet...

