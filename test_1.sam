TEST:2:1:8790:931#0/1	16	_test	100	255	4M	*	0	0	BBBB	____	XA:i:0	MD:Z:4	NM:i:0
TEST:2:1:8790:931#0/1	16	_test	100	255	4M	*	0	0	DDDD	____	XA:i:1	MD:Z:4	NM:i:1
TEST:2:1:8790:931#0/1	0	_test	90	255	4M	*	0	0	EEEE	____	XA:i:0	MD:Z:4	NM:i:0
TEST:2:1:8790:931#0/1	0	_test	100	255	4M	*	0	0	FFFF	____	XA:i:0	MD:Z:4	NM:i:0
TEST:2:1:1071:930#0/1	0	_test	200	255	4M	*	0	0	HHHH	____	XA:i:0	MD:Z:4	NM:i:0
TEST:2:1:4364:947#0/1	0	_test	300	255	4M	*	0	0	KKKK	____	XA:i:0	MD:Z:4	NM:i:0
TEST:2:1:7426:950#0/1	16	_test	400	255	4M	*	0	0	LLLL	____	XA:i:2	MD:Z:1GC1	NM:i:2
TEST:2:1:0311:958#0/1	0	_test	500	255	4M	*	0	0	MMMM	____	XA:i:1	MD:Z:2A1	NM:i:1
@
@ multiple-sequences test - different numbers of reads and of unique sequences
TEST:2:1:8790:931#0/1	0	reads_1_seqs_1	100	255	4M	*	0	0	FFFF	____	XA:i:0	MD:Z:4	NM:i:0
TEST:2:1:8790:931#0/1	0	reads_2_seqs_1	200	255	4M	*	0	0	FFFF	____	XA:i:0	MD:Z:4	NM:i:0
TEST:2:1:8790:931#0/1	0	reads_2_seqs_1	200	255	4M	*	0	0	FFFF	____	XA:i:0	MD:Z:4	NM:i:0
TEST:2:1:8790:931#0/1	0	reads_2_seqs_2	300	255	4M	*	0	0	BBBB	____	XA:i:0	MD:Z:4	NM:i:0
TEST:2:1:8790:931#0/1	0	reads_2_seqs_2	300	255	4M	*	0	0	FFFF	____	XA:i:0	MD:Z:4	NM:i:0
TEST:2:1:8790:931#0/1	0	reads_3_seqs_2	400	255	4M	*	0	0	BBBB	____	XA:i:0	MD:Z:4	NM:i:0
TEST:2:1:8790:931#0/1	0	reads_3_seqs_2	400	255	4M	*	0	0	FFFF	____	XA:i:0	MD:Z:4	NM:i:0
TEST:2:1:8790:931#0/1	0	reads_3_seqs_2	400	255	4M	*	0	0	FFFF	____	XA:i:0	MD:Z:4	NM:i:0
TEST:2:1:8790:931#0/1	0	reads_3_seqs_3	500	255	4M	*	0	0	BBBB	____	XA:i:0	MD:Z:4	NM:i:0
TEST:2:1:8790:931#0/1	0	reads_3_seqs_3	500	255	4M	*	0	0	DDDD	____	XA:i:0	MD:Z:4	NM:i:0
TEST:2:1:8790:931#0/1	0	reads_3_seqs_3	500	255	4M	*	0	0	FFFF	____	XA:i:0	MD:Z:4	NM:i:0
@ 
@ TODO
@ strandedness-position test (assume the position type considered is 3prime; 5prime will be equivalent, and leftmost/rightmost are straightforward)
@
@ TODO
@ ____ test
@
@@@ mutation-handling test (by CIGAR string, NM field and MD field)
@ 1) no mutations
TEST:2:1:4364:947#0/1	0	mutation_none	100	255	4M	*	0	0	BBBB	____	XA:i:0	MD:Z:4	NM:i:0
@ 2) mutation according to all relevant strings - should be detected (note I'm using an Insertion here, bowtie doesn't actually do those, but bowtie seems to only ever yield M's for match/mismatch, so nothing else I can test this with)
TEST:2:1:7426:950#0/1	0	mutation_yes	200	255	3M1D	*	0	0	DDDD	____	XA:i:0	MD:Z:3L	NM:i:1
@ 3) mutation according to MD and NM strings only, CIGAR string ambiguous - should be detected
TEST:2:1:7426:950#0/1	0	mutation_yes	200	255	4M	*	0	0	EEEE	____	XA:i:0	MD:Z:3L	NM:i:1
@ 4) mutation according to CIGAR string only - should be detected (again note that bowtie never has CIGAR strings like this; also note that I had to make CIGAR 4D, because 3M1D is seen as ambiguous and thus passed on to check NM/MD)
TEST:2:1:7426:950#0/1	0	mutation_yes	200	255	4D	*	0	0	FFFF	____	XA:i:0	MD:Z:4	NM:i:0
@ 5) mutation according to NM string only - should be detected (my program checks NM first, then MD)
TEST:2:1:0311:958#0/1	0	mutation_yes	200	255	4M	*	0	0	HHHH	____	XA:i:0	MD:Z:4	NM:i:1
@ 6) mutation according to MD string only - shouldn't be detected (my program checks NM first, then MD)
TEST:2:1:0311:958#0/1	0	mutation_none	100	255	4M	*	0	0	KKKK	____	XA:i:0	MD:Z:1P2	NM:i:0
@ 7)mutation according to MD string but the NM string is missing - should be detected (my program checks NM first, then MD)
TEST:2:1:0311:958#0/1	0	mutation_yes	200	255	4M	*	0	0	LLLL	____	XA:i:0	MD:Z:1P2
@
@ unaligned reads test (should be ten of them)
TEST:2:1:3000:928#0/1	4	*	0	0	*	*	0	0	AAAA	____	XM:i:0
TEST:2:1:3115:932#0/1	4	*	0	0	*	*	0	0	TTTT	_b_b	XM:i:0
TEST:2:1:3183:928#0/1	4	*	0	0	*	*	0	0	AAAA	bb_b	XM:i:0
TEST:2:1:3253:930#0/1	4	*	0	0	*	*	0	0	AAAA	b__b	XM:i:0
TEST:2:1:3578:931#0/1	4	*	0	0	*	*	0	0	TTTT	____	XM:i:0
TEST:2:1:5112:931#0/1	4	*	0	0	*	*	0	0	AAAA	_bbb	XM:i:0
TEST:2:1:5345:929#0/1	4	*	0	0	*	*	0	0	AAAA	__bb	XM:i:0
TEST:2:1:5392:940#0/1	4	*	0	0	*	*	0	0	TTTT	bbb_	XM:i:0
TEST:2:1:5392:950#0/1	4	*	0	0	*	*	0	0	AAAA	bbbb	XM:i:0
TEST:2:1:5392:960#0/1	4	*	0	0	*	*	0	0	AAAA	bbb_	XM:i:0
