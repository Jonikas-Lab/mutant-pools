#!/usr/bin/env python
""" Go from a file containing genomic locations of mutants (generated by deepseq_count_alignments.py) to a file describing which gene (if any) was hit;  possibly also including gene feature (UTR, exon, etc);  possibly with using another reference file to get gene names/descriptions instead of just obscure IDs.

WORK IN PROGRESS.

 -- Weronika Patena, Jonikas Lab, Carnegie Institution, 2011

USAGE: deepseq_find_hit_locations.py [options] mutant_file [mutant_file2 mutant_file3 ...] gene_file outfile """

import sys, time
import unittest
from general_utilities import write_header_data
import deepseq_analysis_classes
from BCBio import GFF


def find_gene_by_pos(chromosome, position, reference_by_chromosome, chromosomes_seen_already=[], error_for_tests=False):
    """ If the location given by chromosome/position is inside a gene, return geneID; otherwise return "no_gene_found".
    Gene locations from reference_by_chromosome - a chromosome:record dict, with records generated by BCBio.GFF parser. 
    chromosomes_seen_already is a list used to store data between function runs, in order to suppress repeated warnings 
     about sequences absent in reference_by_chromosome. A pre-populated list can be passed if desired.
    """
    # fail gracefully when you see an unexpected "chromosome"; keep track in order to only print the warning once
    if not chromosome in reference_by_chromosome.keys():
        if not chromosome in chromosomes_seen_already:
            # Normally I want printing, but when running tests it's hard to test printing, so adding an exception option
            info = 'Warning: chromosome "%s" not found in gene_file data! (No further warnings will be shown)'%(chromosome)
            if error_for_tests:     raise ValueError(info)
            else:                   print(info)
        chromosomes_seen_already.append(chromosome)
        return deepseq_analysis_classes.SPECIAL_GENE_CODES.chromosome_not_in_reference
    # see notes_on_GFF_parsing.txt for what a GFF record (reference_by_chromosome[chromosome]) will be like
    for gene in reference_by_chromosome[chromosome].features:
        if gene.location.start.position < position < gene.location.end.position:
            return gene.id
        # MAYBE-TODO do I want to check the strand?  No, it's actually irrelevant which way the cassette is, right?
    return deepseq_analysis_classes.SPECIAL_GENE_CODES.not_found


######### Test code #########

# TODO none of this testing code is actually done!  Just empty frameworks and copies from old code.

class Testing_functions(unittest.TestCase):
    """ Unit-tests for various functions in this module. """

    # mock-ups of GFF objects for testing
    class Fake_chromosome():
        class Fake_gene():
            class Fake_nothing():  pass
            def __init__(self,start,end,ID):
                self.id = ID
                self.location = self.Fake_nothing()
                self.location.start = self.Fake_nothing()
                self.location.end = self.Fake_nothing()
                self.location.start.position = start
                self.location.end.position = end
        def __init__(self,gene_data_list):
            self.features = []
            for start,end,ID in gene_data_list:
                self.features.append(self.Fake_gene(start,end,ID))
    fake_genes_set1 = [(5,10,'gene1'), (20,30,'gene2'), (50,100,'gene3')]
    fake_genes_set2 = [(2,3,'gene4'), (40,60,'gene4'), (80,90,'gene6')]
    fake_chrom_data = {'chr1': Fake_chromosome(fake_genes_set1), 'chr2': Fake_chromosome(fake_genes_set2)}

    def test__find_gene_by_pos(self):
        """ Unit-tests for find_gene_by_pos function. """
        pass


def do_test_run():
    """ Test run: run script on test infile, compare output to reference file."""
    test_runs = [("-H 1 -s -n3 -o -q -U -p leftmost","test_data/test_input.sam","test_data/test_output__U_leftmost.txt"),
                 ("-H 1 -s -n3 -o -q -U -p rightmost","test_data/test_input.sam","test_data/test_output__U_rightmost.txt"),
                 ("-H 1 -s -n3 -o -q -U -p 5prime","test_data/test_input.sam","test_data/test_output__U_5prime.txt"),
                 ("-H 1 -s -n3 -o -q -U -p 3prime","test_data/test_input.sam","test_data/test_output__U_3prime.txt"),
                 ("-H 1 -s -n3 -o -q -u -p leftmost","test_data/test_input.sam","test_data/test_output__u_leftmost.txt")]
    #  (using -s and -H 1 to get all relevant info but not have to deal with changing timestamps/etc)
    for option_string, infile, reference_file in test_runs:
        print(" * New test run, with options: %s (infile %s, reference outfile %s)"%(option_string,infile,reference_file))
        # regenerate options with test argument string
        parser = define_option_parser()
        (options, _) = parser.parse_args(option_string.split())
        outfile = "test_data/test_output.txt"
        run_main_function([infile], outfile, options)
        # compare outfile to reference file: remove outfile and keep going if correct, otherwise exit with message.
        if filecmp.cmp(outfile, reference_file, shallow=False):
            os.remove(outfile)
        else:
            print("TEST FAILED!!  Reference file %s and output file %s differ - PLEASE COMPARE."%(reference_file,outfile))
            return 1
    print("*** Test runs finished - EVERYTHING IS FINE. ***")
    return 0


######### Main function code #########

def define_option_parser():
    """ Populates and returns an optparse option parser object, with __doc__ as usage."""
    from optparse import OptionParser
    parser = OptionParser(__doc__)
    parser.add_option('-t','--test_functionality', action='store_true', default=False, 
                      help="Run the built-in unit test suite (ignores all other options/arguments; default %default).")
    parser.add_option('-T','--test_run', action='store_true', default=False, 
                      help="Run on a test input file, check output against reference files. "
                          +"Ignores all other options/arguments. (default %default).")
    parser.add_option('-g', '--gene_name_reference_file', default=None, metavar='FILE', 
                      help="File to use to look up gene names/descriptions from symbols (default %default)"
                          +"       NOT IMPLEMENTED")
    # TODO implement! Get gene name and hopefully description, and maybe GO factors and things...
    parser.add_option('-d', '--detailed_gene_features', action="store_true", default=False,
                      help="In addition to figuring out which gene a mutant falls inside, attempt to find out what "
                          +"part of the gene it hit (UTR,intron,exon) - may take a LOT of memory! (default %default)"
                          +"      NOT IMPLEMENTED")
    # TODO implement! GFF parsing already works, the problem is just that it seems to take up a lot of memory... 
    #   also sometimes gene structure is CONFUSING, there are splice variants and weird-positioned UTRs/exons and what not.
    #   if I do get this, where should it go?  Possibly in parentheses next to gene name in standard by-mutant output, 
    #     and I suppose in by-gene output there should be a column for number of mutants hitting various features...
    parser.add_option('-D', '--no_detailed_gene_features', action="store_false", dest='detailed_gene_features',
                      help="Turns -d off.")
    parser.add_option('-H', '--header_level', choices=['0','1','2'], default='2', metavar='0|1|2', 
                      help="Outfile header type:  0 - no header at all, 1 - a single line giving column headers, "
                          +"3 - full header with command, options, date, user etc (default %default) (also see -s)")
    parser.add_option('-s', '--add_summary_to_file', action="store_true", default=True, 
                      help="Print summary at the end of the file (default %default) (also see -H)")
    parser.add_option('-S', '--dont_add_summary_to_file', action="store_false", dest='add_summary_to_file', 
                      help="Turn -s off.")
    parser.add_option('-o', '--sort_data_by_position', action="store_true", default=False, 
                      help="Sort the output data by alignment position (default %default) - CAUTION: MAY BE SLOW!")
    parser.add_option('-O', '--dont_sort_data_by_position', action="store_false", dest='sort_data_by_position', 
                      help="Turn -o off.")
    parser.add_option('-a', '--assume_new_sequences', choices=[True,False], default=False, metavar="True|False", 
                      help="How to deal with one mutant in multiple mutant files? If it has a unique sequence variant" 
                          +" count of 2 and 3, True would make the total 5, and False 3 (default %default)")
    parser.add_option('-q', '--quiet', action="store_true", default=False, help="Don't print summary to STDOUT.")
    parser.add_option('-v', '--verbose', action="store_true", default=False, help="Print progress reports to STDOUT.")
    # MAYBE-TODO add a "flank" option (with variable size), to catch mutants that are in the flanks of genes? Do we care?
    # MAYBE-TODO add a "negative flank" option (with variable size), to ignore mutants that are in the start/end of genes?

    return parser
    # TODO is all of this actually implemented/used?  Check!


def run_main_function(mutant_files, gene_file, outfile, options):
    """ Run the main functionality of the module (see module docstring for more information), excluding testing.
    The options argument is generated by an optparse parser.
    """
    all_mutants_by_pos = deepseq_analysis_classes.All_alignments_grouped_by_pos(position_type=None)

    if options.verbose: print "parsing mutant input files... - time %s."%(time.ctime())

    for mutant_file in mutant_files:
        if options.verbose: print "\tfile %s - time %s."%(mutant_file, time.ctime())
        all_mutants_by_pos.read_from_file(mutant_file, options.assume_new_sequences)

    if not options.quiet:   all_mutants_by_pos.print_summary()

    if options.verbose: print "parsing gene_file %s... - time %s."%(gene_file, time.ctime())
    # parse the gene_file reference using BCBio.GFF - first ONLY look at "gene" features
    genefile_parsing_limits = {'gff_type': ['gene']}
    reference_by_chromosome = {}
    with open(gene_file) as GENEFILE:
        for record in GFF.parse(GENEFILE, limit_info=genefile_parsing_limits):
            #if options.verbose:   print "\tparsing %s..."%record.id
            reference_by_chromosome[record.id] = record
    # For checking various things in the gff file that are unrelated to mutant-location, see gff_examine_file.py

    mutants_undetermined, mutants_not_in_genes, mutants_in_genes = 0,0,0
    all_genes = set()

    # go over all mutants, and figure out which gene they're in (if any)
    for mutant in all_mutants_by_pos.data_by_position.itervalues():
        gene = find_gene_by_pos(mutant.chromosome, mutant.position, reference_by_chromosome, ['insertion_cassette'])
        mutant.gene = gene
        if gene==deepseq_analysis_classes.SPECIAL_GENE_CODES.chromosome_not_in_reference:   
            mutants_undetermined += 1
        elif gene==deepseq_analysis_classes.SPECIAL_GENE_CODES.not_found:                   
            mutants_not_in_genes += 1
        else:                                                                               
            mutants_in_genes += 1
            all_genes.add(gene)

    # MAYBE-TODO figure out the totals of how many mutants were/weren't in a gene, print that
    summary = []
    summary.append("%s mutants in genes"%mutants_in_genes)
    summary.append("%s mutants not in genes"%mutants_not_in_genes)
    summary.append("%s mutants undetermined"%mutants_undetermined)
    summary.append("%s genes hit by at least one mutant"%len(all_genes))
    for text in summary:    print text

    # print output - this is old code but may pretty much work... (MAYBE-TODO in which case I may want to refactor to avoid code duplication between this file and deepseq_count_alignments.py, and either make all this header-printing with various options a function in itself, or just stick this in as a class method for deepseq_analysis_classes.py?

    if options.verbose: print "printing output - time %s."%time.ctime()
    options.header_level = int(options.header_level)
    with open(outfile,'w') as OUTFILE:
        if options.header_level==2:
            write_header_data(OUTFILE,options)
        if options.add_summary_to_file:
            OUTFILE.write("### SUMMARY:\n")
            all_mutants_by_pos.print_summary(OUTFILE, "# ")
        if options.header_level==2:
            OUTFILE.write("### HEADER AND DATA:\n")
        elif options.add_summary_to_file:
            OUTFILE.write("### DATA:\n")
        header_line = True if options.header_level else False
        header_prefix = '' if options.header_level==1 else '# '
        all_mutants_by_pos.print_data(OUTPUT=OUTFILE, sort_data=options.sort_data_by_position, 
                                      N_sequences=0, header_line=header_line, header_prefix=header_prefix)
        # MAYBE-TODO do I want N_sequences to always be 0 here, or not necessarily?

    # MAYBE-TODO I may want another output file that's per-gene instead of per-mutant, especially once I have more gene info (like names and descriptions and GO terms) instead of just IDs
    # MAYBE-TODO also modify the print_summary function in  All_alignments_grouped_by_pos to include extra stuff like how many mutants are in genes, how many total genes were hit, how many mutants per gene, ...


if __name__ == "__main__":
    """ Allows both running and importing of this file. """

    parser = define_option_parser()
    (options, args) = parser.parse_args()

    # if ran with -t option, do unit tests and quit
    if options.test_functionality:
        print("*** You used the -t option - ignoring all other options/arguments, running the built-in test suite. ***")
        print("      (testing both the deepseq_analysis_classes.py module and this module)")
        # to run tests for another file, have to use TextTestRunner, not unittest.main -  make a test suite with 
        #   autodetection of all tests (see http://docs.python.org/library/unittest.html#unittest.TestLoader)
        test_suite_1 = unittest.defaultTestLoader.loadTestsFromModule(deepseq_analysis_classes)
        unittest.TextTestRunner(verbosity=1).run(test_suite_1)
        # to run tests for current module, just run unittest.main, passing it only the filename 
        #   (by default it takes all of sys.argv and complains about options/arguments it can't recognize)
        unittest.main(argv=[sys.argv[0]])   # unittest.main automatically runs sys.exit()

    if options.test_run:
        print("*** You used the -T option - ignoring all other options and running the built-in example test runs. ***")
        test_result = do_test_run()
        sys.exit(test_result)

    # otherwise parse the arguments and run main function
    if len(args)<3:
        parser.print_help()
        sys.exit("\nError: at least one mutant_file, exactly one gene_file and exactly one outfile are required!")
    mutant_files = args[:-2]
    gene_file = args[-2]
    outfile = args[-1]

    run_main_function(mutant_files, gene_file, outfile, options)


    # MAYBE-TODO do I want to try outputting this in some existing bioinformatics format instead of a made-up one?

    # MAYBE-TODO add an option to make output go to STDOUT?
